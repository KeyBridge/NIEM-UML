//import niemcommonBase;
import NIEMpsm2xsd;
import NIEMplatformBinding;
//import pim2psmPlatformBinding;
//import pim2mpd;
//import pim2ndr;
//import pim2xsd;
//import uml2mpdPlatformBinding;
//import pim2psmPlatformBinding;
//import uml2xsdPlatformBinding;
/* TEMP
import uml2ndrPlatformBinding;
import uml2xsdPlatformBinding;
*/
//modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.1.2';
//modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.4.1';
//modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.5';
modeltype UML uses 'http://www.omg.org/spec/UML/20131001';

modeltype CMOF  uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';
modeltype PROXY uses 'http://release.niem.gov/niem/proxy/xsd/3.0/';
//modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/1.0/';
modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/3.0/';

modeltype OASIS  uses 'urn:oasis:names:tc:entity:xmlns:xml:catalog';

//modeltype CHANGELOG uses 'http://reference.niem.gov/niem/resource/mpd/changelog/1.0/';
modeltype CHANGELOG uses 'http://reference.niem.gov/niem/resource/mpd/changelog/1.1/';

//modeltype PROXY uses 'http://niem.gov/niem/proxy/xsd/2.0';
//modeltype WANTLIST uses 'http://niem.gov/niem/wantlist/2';// EXTRA
modeltype WANTLIST uses 'http://niem.gov/niem/wantlist/2.2';// EXTRA
modeltype NC uses 'http://release.niem.gov/niem/niem-core/3.0/';

transformation NIEMmpdmodel2artifact(in uml:UML,
	in schemaForProxy:XSD,in schemaForStructures:XSD,in schemaForAppinfo:XSD,
	//in schemaForAppinfo2:XSD, // not in NIEM3
	in schemaForConformanceTargets:XSD,in schemaForLocalTerminology:XSD,
	//out changeLog:CHANGELOG,  moved to platform specific
	out xsd:XSD,inout blackboxAdapter:CMOF,out cat:CAT
	,out oasis:OASIS
	,out wantlist:WANTLIST 
	)
	extends transformation
//	pim2psmPlatformBinding,
//	pim2mpd(uml:UML,changeLog:CHANGELOG,xsd:XSD,blackboxAdapter:CMOF,cat:CAT),
//	uml2mpdPlatformBinding(uml:UML,xsd:XSD),
//	pim2ndr(uml:UML,xsd:XSD,blackboxAdapter:CMOF),
//	uml2ndrPlatformBinding(uml:UML,xsd:XSD),uml2xsdPlatformBinding(uml:UML,xsd:XSD),
//	pim2xsd(uml:UML,xsd:XSD),
//	uml2xsdPlatformBinding(in UML,out XSD),
//	niemcommonBase,
	NIEMpsm2xsd(uml:UML,schemaForProxy:XSD,schemaForStructures:XSD,schemaForAppinfo:XSD,
		//schemaForAppinfo2:XSD,// not in niem3
		schemaForConformanceTargets:XSD,schemaForLocalTerminology:XSD,
		xsd:XSD 
		);

	main() {
		blackboxHook:=blackboxAdapter.objectsOfType(CMOF::EPackage)->asSequence()->first();
	mpdmodel2artifactMain();
	return;
	}
helper mpdmodel2artifactMain(){
		NIEMpsm2mpdMain();
		/////////////////////////EXTRA
		var wantlistDocument:WANTLIST::DocumentRoot=new WANTLIST::DocumentRoot@wantlist();// EXTRA
		log('wantlist '+wantlistDocument.repr());
		wantlistPrefixes(wantlistDocument);
		var topWantList:WANTLIST::WantListType=new WANTLIST::WantListType@wantlist();// EXTRA
		wantlistDocument.wantList+=topWantList;
		topWantList.release:='2.1';// EXTRA
		topWantList.product:='NIEM';// EXTRA
		log('wantlist gather schemas');
		var schemas:Set(XSD::XSDSchema)=xsd.rootObjects()
			->select(x|x.oclIsKindOf(XSD::XSDSchema)).oclAsType(XSD::XSDSchema)->asSet();
		log('wantlist attribute');
		schemas.wantlistAttribute(topWantList);
		log('wantlist element');
		schemas.wantlistElement(topWantList);
		log('wantlist type');
		schemas.wantlistType(topWantList);
		log('wantlist complete '+wantlistDocument.repr());
		///////////////////////////////sort contents of schemas
		schemas->forEach(schema){
			schema.contents:=schema.contents->sortedBy(content|content.schemaContentOrder());
		};
		return;
}	
query XSD::XSDSchemaContent::schemaContentOrder():String{
	// sort by annotation, import, other, attribute,element,type
	if(self.oclIsKindOf(XSD::XSDAnnotation))then {return 'a'+self.repr();}endif;
	if(self.oclIsKindOf(XSD::XSDImport))then {return 'b'+self.oclAsType(XSD::XSDImport).namespace;}endif;
	if(self.oclIsKindOf(XSD::XSDAttributeDeclaration))then {return 'e'+self.oclAsType(XSD::XSDNamedComponent).name;}endif;
	if(self.oclIsKindOf(XSD::XSDElementDeclaration))then {return 'f'+self.oclAsType(XSD::XSDNamedComponent).name;}endif;
	if(self.oclIsKindOf(XSD::XSDTypeDefinition))then {return 'g'+self.oclAsType(XSD::XSDNamedComponent).name;}endif;
	if(self.oclIsKindOf(XSD::XSDNamedComponent))then {return 'c'+self.oclAsType(XSD::XSDNamedComponent).name;}endif;
	return 'd'+self.repr();
}
helper catalog(){
		var documentRoot:CAT::DocumentRoot:=new CAT::DocumentRoot@cat();
		documentRoot.catalog+=mpdComponent.map ModelPackageDescription();

		// OASIS catalog, do one for base-xsd, optionally constraint-xsd
		var rootPackage:UML::Package=mpdComponent.getNearestPackage().getNearesProfileApplication(niemXsdProfile);
		var basePackage:UML::Package=rootPackage.nestedPackage->select(p|p.name='base-xsd')->asSequence()->first();
		if(not(basePackage.oclIsUndefined()))then{
			var oasisDocumentRoot:OASIS::DocumentRoot:=new OASIS::DocumentRoot@oasis();
			oasisDocumentRoot.catalog+=mpdComponent.map OasisCatalog(basePackage);
		}endif;
		// dummy changelog
		// moved to platform specific
		/*
		var changeLogx:CHANGELOG::ChangeLogType=new CHANGELOG::ChangeLogType@changeLog();
		log('changeLog '+changeLogx.repr());

		var proxyText:PROXY::_String:=new PROXY::_String();
		proxyText.value:='Sample Summary';
		var proxySubmitter:PROXY::_String:=new PROXY::_String();
		proxySubmitter.value:='Sample Submitter';
		changeLogx.changeLogSummaryText:=proxyText;
		changeLogx.changeLogSubmitterName:=proxySubmitter;
		*/
		return;
}
//////////////////////OASIS
//mapping UML::Component	::OasisCatalog():OASIS::Catalog
mapping UML::InstanceSpecification	::OasisCatalog(basePackage:UML::Package):OASIS::Catalog@oasis
{
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var pimmpd:UML::InstanceSpecification=self;
	pimmpd.getMpdFileUsages()
		->union(pimmpd.getInstanceValues('IEPConformanceTarget').getInstanceValues('ValidityConstraintWithContext').getMpdFileUsages())
		.map Uri(basePackage,result);
//	self.clientDependency
//		->select(t|t.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype)).oclAsType(UML::Usage)
//		.map Uri(result);
}
mapping UML::Usage::Uri(basePackage:UML::Package,inout catalog:OASIS::Catalog):OASIS::Uri@oasis
	when{self.supplier->select(s|s.oclIsKindOf(UML::Package) and s.oclAsType(UML::Package).isNIEMNamespace())->notEmpty()}
{
	catalog.uri+=result;
	var schemaPackage:UML::Package=self.supplier
		->select(s|s.oclIsKindOf(UML::Package) and s.oclAsType(UML::Package).isNIEMNamespace()).oclAsType(UML::Package)
		->asSequence()->first();
//	uri:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
	uri:=schemaPackage.toRelativePathName(basePackage,result);
	if(result.uri.oclIsUndefined())then{
		uri:='../'+schemaPackage.toRelativePathName(basePackage.nestingPackage,result);
	}endif;
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMModelPackageDescriptionFileStereotype).oclAsType(Stdlib::Element);
//	var pimmpd:Stdlib::Element=self.client->asSequence()->first().oclAsType(Stdlib::Element);
//	var pimmpd:UML::InstanceSpecification=self.client->asSequence()->first().oclAsType(UML::InstanceSpecification);
	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMFileType).oclAsType(Stdlib::Element);
	var explicitRelativePathName:String =pimmpd.getFileTypeRelativePathName();
	if(not(explicitRelativePathName.oclIsUndefined()) and (explicitRelativePathName<>''))then{
		uri:=explicitRelativePathName;
	}endif;
	name:=schemaPackage.getTargetNamespace();
}
///////////////////////////
mapping String::TextType(context:UML::NamedElement):NC::TextType
{
	value:=self;
}
mapping String::PersonNameType(context:UML::NamedElement):NC::PersonNameType
{
	personFullName+=self.map PersonNameTextType(context);
}

mapping String::ProperNameTextType(context:UML::NamedElement):NC::ProperNameTextType
	inherits String::TextType
{
}
mapping String::PersonNameTextType(context:UML::NamedElement):NC::PersonNameTextType
	inherits String::ProperNameTextType
{
}
//mapping UML::Component	::ModelPackageDescription():CAT::CatalogType
mapping UML::InstanceSpecification	::ModelPackageDescription():CAT::CatalogType@cat
{
	mpdComponent:=self;
	self.getTopNiemFolders().nestedPackage.mapAbstractPackage();
	log('processCatalog start ');
		
//	var md:CAT::MPDType=new CAT::MPDType();
//	mPD:=md;
	mPD:=self.map MPDType();
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var pimmpd:UML::InstanceSpecification=self;
//	pimmpd.getMpdFileUsages().map AbstractModelPackageDescriptionFile(result);
	pimmpd.getMpdFileUsages().map AbstractModelPackageDescriptionFile(result.mPD);
//	self.clientDependency
//		->select(t|t.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype)).oclAsType(UML::Usage)
//		.map ModelPackageDescriptionFile(result);
	log('processCatalog complete ');
}
//mapping UML::Component	::MPDType():CAT::MPDType
mapping UML::InstanceSpecification	::MPDType():CAT::MPDType@cat
{
	// mpd
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var pimmpd:UML::InstanceSpecification=self;
	pimmpd.getMpdFileSets().map SchemaDocumentSetType(result);
//	self.packagedElement
//		->select(t|t.isStereotypeApplied(NIEMModelPackageDescriptionFileSetStereotype))
//		.oclAsType(UML::Component)
//		.map SchemaDocumentSetType(result);
	
//	var md:CAT::MetadataType=new CAT::MetadataType();
//	metadata:=md;
//	var ncDescriptionText:NC::TextType=new NC::TextType();
//	ncDescriptionText.value:=pimmpd.getMpdDescriptionText();
//	md.descriptionText:=ncDescriptionText;
//	descriptionText:=pimmpd.getMpdDescriptionText().map TextType(self);
	descriptionText:=pimmpd.getDescriptionText().map TextType(self);
	
	//mPD:=md;
	
	//  IEPConformanceTarget
	pimmpd.getIEPConformanceTargets().map IEPConformanceTarget(result);
	
	
	// ArtifactOrArtifactSet
	pimmpd.getArtifactOrArtifactSetInstances().ArtifactOrArtifactSet(result);
	
//	var mpdInformationType:CAT::MPDInformationType=new CAT::MPDInformationType();
//	mPDInformation:=mpdInformationType;
	mPDInformation:=self.map MPDInformationType();
	mpdURI:=pimmpd.getMpdBaseURI();
//	mpdName:=md.mpdURI.getLastSegment();
	mpdName:=result.mpdURI.getLastSegment();
	mpdVersionID:=pimmpd.getMpdVersionID();
	
	// TODO:  mpdClassCode
	//mpdClassCode:=null;// TODO
	
//	var classURIs:Sequence(String)=Sequence{};	
//	classURIs+='http://reference.niem.gov/niem/specification/model-package-description/3.0/#MPD';	
	result.oclAsType(Stdlib::Element).addListValue('mpdClassURIList','http://reference.niem.gov/niem/specification/model-package-description/3.0/#MPD');
	var mpdClassCode:String=pimmpd.getMpdClassCode();
	switch{
		case(false){}
		else{
//			classURIs+='http://reference.niem.gov/niem/specification/model-package-description/3.0/#IEPD';	
			result.oclAsType(Stdlib::Element).addListValue('mpdClassURIList','http://reference.niem.gov/niem/specification/model-package-description/3.0/#IEPD');
		};
	};
	
	// TODO: check if this is only problem
	//mpdClassURIList:=classURIs;
	
/*		
	mpdClassURIList:=Sequence{};	
	mpdClassURIList+='http://reference.niem.gov/niem/specification/model-package-description/3.0/#MPD';	
	var mpdClassCode:String=pimmpd.getMpdClassCode();
	switch{
		case(false){}
		else{
			mpdClassURIList+='http://reference.niem.gov/niem/specification/model-package-description/3.0/#IEPD';	
		};
	};
	
 */
//	      http://reference.niem.gov/niem/specification/model-package-description/3.0/#IEPD	
/*
<xs:element ref="c:AuthoritativeSource" minOccurs="0"/>
            <xs:element ref="c:CreationDate" minOccurs="0"/>
            <xs:element ref="c:LastRevisionDate" minOccurs="0"/>
            <xs:element ref="c:StatusText" minOccurs="0"/>
            <xs:element ref="c:Relationship" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="c:KeywordText" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="c:DomainText" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="c:PurposeText" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="c:ExchangePatternText" minOccurs="0" maxOccurs="unbounded"/>
	    <xs:element ref="c:ExchangePartnerName" minOccurs="0" maxOccurs="unbounded"/>
	    <xs:element ref="c:ExtendedInformation" minOccurs="0" maxOccurs="unbounded"/>
	var as:CAT::AuthoritativeSourceType=new CAT::AuthoritativeSourceType();
	md.authoritativeSource:=as;
*/	    		
	
	
	
	//descriptionText:=pimmpd.getMpdDescriptionText();
	//mpdURI:=pimmpd.getMpdBaseURI();
	//mpdName:=mpdURI.getLastSegment();
	//mpdVersionID:=pimmpd.getMpdVersionID();
	// TODO: is there a securityMarkingText?
//	md.securityMarkingText:=pimmpd.getMpdSecurityMarkingText();
//TODO	md.creationDate:=self.getAnyValue(artifactStereotype,'CreationDate').oclAsType(XSD::Date);
//pimmpd.getMpdCreationDate()
/*
	md.statusText:=pimmpd.getMpdStatusText();
	md.keywordText:=pimmpd.getMpdKeywordText();
	md.domainText:=pimmpd.getMpdDomainText();
	md.purposeText:=pimmpd.getMpdPurposeText();
	md.exchangePatternText:=pimmpd.getMpdExchangePatternText();
	md.exchangePartnerName:=pimmpd.getMpdExchangePartnerName();
	*/
	
//	pimmpd.map EntityType(mpdInformationType,self);
	pimmpd.map EntityType(mPDInformation,self);
	
	
	// TODO: aSAddressTExt
	// TODO: aSWebSiteURL
	/*
	as.aSName:=pimmpd.getMpdASName();
	as.aSAddressText:=pimmpd.getMpdASAddressText();
	as.aSWebSiteURL:=pimmpd.getMpdASWebSiteURL();
	*/
//	self.clientDependency.map ModelPackageDescriptionRelationship(md);
//	self.clientDependency.map ModelPackageDescriptionRelationship(mpdInformationType);
//if(false)then{// test debug
	self.clientDependency.map ModelPackageDescriptionRelationship(result.mPDInformation);
//}endif;	
}
mapping UML::InstanceSpecification	::IEPConformanceTarget(inout mpdType:CAT::MPDType):CAT::IEPConformanceTargetType@cat
{
	mpdType.iEPConformanceTarget+=result;
	self.getValidityConstraintWithContext().ValidityConstraintWithContext(result);
	descriptionText:=self.getDescriptionText().map TextType(self);
	
	// ArtifactOrArtifactSet
	self.getArtifactOrArtifactSetInstances().ArtifactOrArtifactSet(result);
//	self.getMpdFileUsages().map AbstractModelPackageDescriptionFileCT(result);
	self.getMpdFileUsages().map AbstractModelPackageDescriptionFile(result);
	
	/*
	var umlIEPConformanceTargetList:UML::Slot=pimmpd.getIEPConformanceTargetList();
	self.iEPConformanceTarget->forEach(iepConformanceTarget){
		var umlIEPConformanceTarget:UML::InstanceSpecification=umlIEPConformanceTargetList.createInstance();
		umlIEPConformanceTarget.setDescriptionText(iepConformanceTarget.descriptionText.value);
		iepConformanceTarget.ValidityConstraintWithContext(umlIEPConformanceTarget);
		umlIEPConformanceTarget.ArtifactOrArtifactSet(iepConformanceTarget);
    };
	*/
}
/*
mapping UML::Usage::AbstractModelPackageDescriptionFileCT(inout catalog:Stdlib::Element):CAT::FileType
	disjuncts 
		UML::Usage::ApplicationInfoCT,
		UML::Usage::BusinessRulesArtifactCT,
		UML::Usage::ConformanceAssertionCT,
		UML::Usage::ConformanceReportCT,
		UML::Usage::DocumentationCT,
		UML::Usage::ExtensionSchemaDocumentFileCT,
		UML::Usage::ExternalSchemaDocumentFileCT,
		UML::Usage::FileCT,
		UML::Usage::IEPSampleXMLDocumentCT,
		UML::Usage::MPDChangeLogCT,
		UML::Usage::ReadMeCT,
		UML::Usage::ReferenceSchemaDocumentFileCT,
		UML::Usage::RelaxNGSchemaCT,
		UML::Usage::RequiredFileCT,
		UML::Usage::SchematronSchemaCT,
		UML::Usage::SubsetSchemaDocumentFileCT,
		UML::Usage::WantlistCT,
		UML::Usage::XMLCatalogCT,
		UML::Usage::XMLSchemaDocumentCT,

		UML::Usage::ModelPackageDescriptionFileCT
	{}
mapping UML::Usage::ExternalSchemaDocumentFileCT(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ExternalSchemaDocument')}
{
	catalog.addExternalSchemaDocument(result);
}
mapping UML::Usage::ExtensionSchemaDocumentFileCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ExtensionSchemaDocument')}
{
	catalog.addExtensionSchemaDocument(result);
}
mapping UML::Usage::ReferenceSchemaDocumentFileCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ReferenceSchemaDocument')}
{
	catalog.addReferenceSchemaDocument(result);
}
	
mapping UML::Usage::SubsetSchemaDocumentFileCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('SubsetSchemaDocument')}
{
	catalog.addSubsetSchemaDocument(result);
}
mapping UML::Usage::XMLCatalogCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('XMLCatalog')}
	{
	catalog.addXMLCatalog(result);
}	
mapping UML::Usage::XMLSchemaDocumentCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('XMLSchemaDocument')}
	{
	catalog.addXMLSchemaDocument(result);
}	
mapping UML::Usage::RequiredFileCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('RequiredFile')}
	{
	catalog.addRequiredFile(result);
}	
mapping UML::Usage::SchematronSchemaCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('SchematronSchema')}
	{
	catalog.addSchematronSchema(result);
}	
mapping UML::Usage::WantlistCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('Wantlist')}
	{
	catalog.addWantlist(result);
}	
mapping UML::Usage::MPDChangeLogCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('MPDChangeLog')}
	{
	catalog.addMPDChangeLog(result);
}	
mapping UML::Usage::ReadMeCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ReadMe')}
	{
	catalog.addReadMe(result);
}	
mapping UML::Usage::RelaxNGSchemaCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('RelaxNGSchema')}
	{
	catalog.addRelaxNGSchema(result);
}	
mapping UML::Usage::DocumentationCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('Documentation')}
	{
	catalog.addDocumentation(result);
}	
mapping UML::Usage::FileCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('File')}
	{
	catalog.addFile(result);
}	
mapping UML::Usage::IEPSampleXMLDocumentCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('IEPSampleXMLDocument')}
	{
	catalog.addIEPSampleXMLDocument(result);
}	
mapping UML::Usage::BusinessRulesArtifactCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('BusinessRulesArtifact')}
	{
	catalog.addBusinessRulesArtifact(result);
}	
mapping UML::Usage::ConformanceAssertionCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ConformanceAssertion')}
	{
	catalog.addConformanceAssertion(result);
}	
mapping UML::Usage::ConformanceReportCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ConformanceReport')}
	{
	catalog.addConformanceReport(result);
}	
	
	
mapping UML::Usage::ApplicationInfoCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('ApplicationInfo')}
	{
	catalog.addApplicationInfo(result);
}	
mapping UML::Usage::ModelPackageDescriptionFileCommonCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	{
	var schemaPackage:UML::NamedElement=self.supplier->asSequence()->first();
//	relativePathName:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
	pathURI:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMModelPackageDescriptionFileStereotype).oclAsType(Stdlib::Element);
//	var pimmpd:Stdlib::Element=self.client->asSequence()->first().oclAsType(Stdlib::Element);
//	var pimmpd:UML::InstanceSpecification=self.client->asSequence()->first().oclAsType(UML::InstanceSpecification);
	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMFileType).oclAsType(Stdlib::Element);
	var explicitRelativePathName:String =pimmpd.getFileTypeRelativePathName();
	if(not(explicitRelativePathName.oclIsUndefined()) and (explicitRelativePathName<>''))then{
//		relativePathName:=explicitRelativePathName;
		pathURI:=explicitRelativePathName;
		
	}endif;
//	descriptionText:=pimmpd.getFileDescriptionText();
//	descriptionText:=pimmpd.getFileDescriptionText().map TextType(self);
	descriptionText:=pimmpd.getDescriptionText().map TextType(self);
	id:=self.getFileId();
//	externalURI:=pimmpd.getFileTypeExternalURI();
	externalURI:=pimmpd.getExternalURI();
	mimeMediaTypeText:=pimmpd.getMimeMediaTypeText();
	// not in NIEM3
	//natureURI:=pimmpd.getFileTypeNatureURI();
	//purposeURI:=pimmpd.getFileTypePurposeURI();
}
mapping UML::Usage::ModelPackageDescriptionFileCT(inout catalog:CAT::IEPConformanceTargetType):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommonCT
	when{self.stereotypedBy('FileType')}
	{
	catalog.addCatalogFile(result);
}
*/
mapping UML::Usage::FileSetFile(inout fileSet:CAT::FileSetType):CAT::FileType@cat{
	//fileSet.file+=result;
	fileSet.addFileSetFile(result);
	
	var schemaPackage:UML::NamedElement=self.supplier->asSequence()->first();

//	relativePathName:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
	pathURI:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMModelPackageDescriptionFileStereotype);
//	var pimmpd:Stdlib::Element=self.client->asSequence()->first().oclAsType(Stdlib::Element);
//	var pimmpd:UML::InstanceSpecification=self.client->asSequence()->first().oclAsType(UML::InstanceSpecification);
	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMFileType);
	var explicitRelativePathName:String =pimmpd.getFileTypeRelativePathName();
	if(not(explicitRelativePathName.oclIsUndefined()) and (explicitRelativePathName<>''))then{
//		relativePathName:=explicitRelativePathName;
		pathURI:=explicitRelativePathName;
	}endif;
//	descriptionText:=pimmpd.getFileDescriptionText();
//	descriptionText:=pimmpd.getFileDescriptionText().map TextType(self);
	descriptionText:=pimmpd.getDescriptionText().map TextType(self);
	
	id:=self.getFileId();
//	externalURI:=pimmpd.getFileTypeExternalURI();
	externalURI:=pimmpd.getExternalURI();
	
	// not in NIEM3
	//natureURI:=pimmpd.getFileTypeNatureURI();
	//purposeURI:=pimmpd.getFileTypePurposeURI();
}
mapping UML::Usage::SubsetSchemaDocument(inout fileSet:CAT::SchemaDocumentSetType):CAT::FileType@cat
	inherits UML::Usage::FileSetFile
{
//	fileSet.xMLSchemaDocument+=result;
//	fileSet.artifactOrArtifactSet+=result;
	fileSet.oclAsType(CMOF::EObject).add('artifactOrArtifactSetGroup','subsetSchemaDocument',result.oclAsType(CMOF::EObject));
	
}

helper UML::InstanceSpecification	::ValidityConstraintWithContext(inout iepConformanceTargetType:CAT::IEPConformanceTargetType)
{
	// TODO
//            <xs:element ref="c:ValidityConstraintWithContext" minOccurs="0" maxOccurs="unbounded"/>
//    <xs:element name="ValidityConstraintWithContext" abstract="true">
//    <xs:element name="ValidityConstraint" abstract="true" substitutionGroup="c:ValidityConstraintWithContext">
//    <xs:element name="ValidityContext" type="c:ValidityContextType" substitutionGroup="c:ValidityConstraintWithContext">
//    <xs:element name="HasDocumentElement" type="c:QualifiedNamesType" substitutionGroup="c:ValidityConstraintWithContext">

//<xs:element name="ValidToXPath" type="c:XPathType" substitutionGroup="c:ValidityConstraint">
//<xs:element name="XMLSchemaValid" type="c:XMLSchemaType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="SchematronValid" type="c:SchematronValidationType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="RelaxNGValid" type="c:RelaxNGValidationType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="ConformsToConformanceTarget" type="c:ConformanceTargetType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="ConformsToRule" type="c:TextRuleType" substitutionGroup="c:ValidityConstraint">
        
	var names:Sequence(String)=self.classifier.name;
			switch{
				case(names->includes('ValidityContextType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','validityContext',self.map ValidityContextType().oclAsType(CMOF::EObject));
				case(names->includes('QualifiedNamesType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','hasDocumentElement',self.map QualifiedNamesType().oclAsType(CMOF::EObject));
				case(names->includes('XPathType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','validToXPath',self.map XPathType().oclAsType(CMOF::EObject));
				case(names->includes('XMLSchemaType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','xMLSchemaValid',self.map XMLSchemaType().oclAsType(CMOF::EObject));
				case(names->includes('SchematronValidationType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','schematronValid',self.map SchematronValidationType().oclAsType(CMOF::EObject));
				case(names->includes('RelaxNGValidationType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','relaxNGValid',self.map RelaxNGValidationType().oclAsType(CMOF::EObject));
				case(names->includes('ConformanceTargetType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','conformsToConformanceTarget',self.map ConformanceTargetType().oclAsType(CMOF::EObject));
				case(names->includes('TextRuleType'))
					iepConformanceTargetType.oclAsType(CMOF::EObject).add('validityConstraintWithContextGroup','conformsToRule',self.map TextRuleType().oclAsType(CMOF::EObject));
	
				else{
					log('ValidityConstraintWithContext not recognized: '+self.repr());
				}
			};
}
mapping UML::InstanceSpecification::ValidityContextType():CAT::ValidityContextType{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:ValidityConstraint" maxOccurs="unbounded"/>
//          </xs:sequence>
//          <xs:attribute ref="c:xPathText" use="required"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	xPathText:=self.getXPathText();
	
	self.getValidityConstraintWithContext()->forEach(validityConstraint){
		var names:Sequence(String)=validityConstraint.classifier.name;
			switch{
				case(names->includes('XPathType'))
					result.oclAsType(CMOF::EObject).add('ValidityConstraintGroup','ValidToXPath',self.map XPathType().oclAsType(CMOF::EObject));
				case(names->includes('XMLSchemaType'))
					result.oclAsType(CMOF::EObject).add('ValidityConstraintGroup','XMLSchemaValid',self.map XMLSchemaType().oclAsType(CMOF::EObject));
				case(names->includes('SchematronValidationType'))
					result.oclAsType(CMOF::EObject).add('ValidityConstraintGroup','SchematronValid',self.map SchematronValidationType().oclAsType(CMOF::EObject));
				case(names->includes('RelaxNGValidationType'))
					result.oclAsType(CMOF::EObject).add('ValidityConstraintGroup','RelaxNGValid',self.map RelaxNGValidationType().oclAsType(CMOF::EObject));
				case(names->includes('ConformanceTargetType'))
					result.oclAsType(CMOF::EObject).add('ValidityConstraintGroup','ConformsToConformanceTarget',self.map ConformanceTargetType().oclAsType(CMOF::EObject));
				case(names->includes('TextRuleType'))
					result.oclAsType(CMOF::EObject).add('ValidityConstraintGroup','ConformsToRule',self.map TextRuleType().oclAsType(CMOF::EObject));
	
				else{
					log('ValidityContextType not recognized: '+validityConstraint.repr());
				}
			};	
	};
} 
mapping UML::InstanceSpecification::QualifiedNamesType():CAT::QualifiedNamesType{
//	            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//          <xs:attribute ref="c:qualifiedNameList" use="required"/>
//    <xs:attribute name="qualifiedNameList" type="c:QualifiedNameListSimpleType">
//    <xs:simpleType name="QualifiedNameListSimpleType">
//      <xs:list itemType="xs:QName"/>
//    </xs:simpleType>
	descriptionText:=self.getDescriptionText().map TextType(self);
	/* TODO
	qualifiedNameList+=self.getQualifiedNameList().toQName();
	*/
} 
mapping UML::InstanceSpecification::XPathType():CAT::XPathType{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//          <xs:attribute ref="c:xPathText" use="required"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	xPathText:=self.getXPathText();
} 
mapping UML::InstanceSpecification::XMLSchemaType():CAT::XMLSchemaType{
//            <xs:element ref="nc:DescriptionText"  minOccurs="0"/>
//            <xs:element ref="c:XMLCatalog"          minOccurs="0" maxOccurs="unbounded"/>
//            <xs:element ref="c:XMLSchemaDocument" minOccurs="0" maxOccurs="unbounded"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	self.getMpdFileUsages().map AbstractXMLSchemaDocument(result);
	
	/* TODO; not sure what this actually means
	self.xMLCatalog.map XMLCatalog(result);// usage
	self.xMLSchemaDocument.map XMLSchemaDocument(result);// usage
	*/
	/* Usage
	var xMLCatalogList:UML::Slot=result.getXMLCatalogList();
	self.xMLCatalog->forEach(xmlCatalog){
		xMLCatalogList.instance:=xmlCatalog.oclAsType(CAT::XMLCatalogType).map XMLCatalogType();
	};
	var xMLSchemaDocumentList:UML::Slot=result.getXMLSchemaDocumentList();
	self.xMLSchemaDocument->forEach(xmlSchemaDocument){
		xmlSchemaDocument.instance:=xmlSchemaDocument.oclAsType(CAT::XMLSchemaDocumentType).map XMLSchemaDocumentType();
	};
*/
} 
mapping UML::InstanceSpecification::SchematronValidationType():CAT::SchematronValidationType{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:SchematronSchema"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	// TODO: not yet supporting Schematron
	//self.schematronSchema.map SchematronSchema(result);// Usage
	//result.setSchematronSchema(self.schematronSchema.value);// Usage
} 
mapping UML::InstanceSpecification::RelaxNGValidationType():CAT::RelaxNGValidationType{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:RelaxNGSchema"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	// TODO: not yet supporting RelaxNG
	//self.relaxNGSchema.map RelaxNGSchema(result);
	//result.setRelaxNGSchema(self.relaxNGSchema.value);// Usage
	

} 
mapping UML::InstanceSpecification::ConformanceTargetType():CAT::ConformanceTargetType{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//          <xs:attribute ref="c:conformanceTargetURI" use="required"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	conformanceTargetURI:=self.getConformanceTargetURI();
} 
mapping UML::InstanceSpecification::TextRuleType():CAT::TextRuleType{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:RuleText"/>
	descriptionText:=self.getDescriptionText().map TextType(self);
	ruleText:=self.getRuleText().map TextType(self);

} 



helper UML::InstanceSpecification	::ArtifactOrArtifactSet(owner:OclAny)
{
	// TODO
}
//mapping UML::Component	::MPDInformationType():CAT::MPDInformationType
mapping UML::InstanceSpecification	::MPDInformationType():CAT::MPDInformationType@cat
{
	// mpd
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var pimmpd:UML::InstanceSpecification=self;
//	creationDate:=self.getAnyValue(prompdStereotype,'CreationDate').getAnyValue().oclAsType(String)
	creationDate:=self.getAnyValue('CreationDate').oclAsType(String)
		.map ProxyDate(pimmpd,'creationDate')->asSequence()->first();
		//.oclAsType(XSD::Date);
//	lastRevisionDate:=self.getAnyValue(prompdStereotype,'LastRevisionDate').getAnyValue().oclAsType(String)
	lastRevisionDate:=self.getAnyValue('LastRevisionDate').oclAsType(String)
		.map ProxyDate(pimmpd,'lastRevisionDate')->asSequence()->first();
	//.oclAsType(String).oclAsType(XSD::Date);
//	mpdInformationType.statusText:=pimmpd.getMpdStatusText();
	statusText:=pimmpd.getMpdStatusText().map ProxyString(pimmpd,'statusText');
	
//	mpdInformationType.keywordText+=pimmpd.getMpdKeywordText();
//	mpdInformationType.domainText+=pimmpd.getMpdDomainText();
//	mpdInformationType.purposeText+=pimmpd.getMpdPurposeText();
//	mpdInformationType.exchangePatternText+=pimmpd.getMpdExchangePatternText();
//	mpdInformationType.exchangePartnerName+=pimmpd.getMpdExchangePartnerName();
//	mpdInformationType.extendedInformation+=pimmpd.getMpdExtendedInformation();


	keywordText+=pimmpd.getMpdKeywordText().map ProxyString(pimmpd,'keywordText');
	domainText+=pimmpd.getMpdDomainText().map ProxyString(pimmpd,'domainText');
	purposeText+=pimmpd.getMpdPurposeText().map ProxyString(pimmpd,'purposeText');
	exchangePatternText+=pimmpd.getMpdExchangePatternText().map ProxyString(pimmpd,'exchangePatternText');
	exchangePartnerName+=pimmpd.getMpdExchangePartnerName().map ProxyString(pimmpd,'exchangePartnerName');
	// extendedInformation is abstract, and there is no substitution
	//mpdInformationType.extendedInformation+=pimmpd.getMpdExtendedInformation().map ProxyString(pimmpd,'extendedInformation');
	
	
}
/*
mapping 	UML::InstanceSpecification::AbstractEntityRepresentation(inout mpdInformationType:CAT::MPDInformationType,context:UML::NamedElement):NC::EntityType
	disjuncts 
		UML::InstanceSpecification::PersonType,
		UML::InstanceSpecification::OrganizationType,
		UML::InstanceSpecification::EntityType
	{}
*/
mapping UML::InstanceSpecification::EntityType(inout mpdInformationType:CAT::MPDInformationType,context:UML::NamedElement):NC::EntityType{
	mpdInformationType.authoritativeSource:=result;
	var entityRepresentations:Sequence(InstanceSpecification)=
		self.getAuthoritativeSourceList().value->select(v|v.oclIsKindOf(InstanceValue)).oclAsType(InstanceValue).instance;
	entityRepresentations->forEach(entityRepresentation){
		var isOrganization:Boolean=entityRepresentation.classifier.name->includes('OrganizationType');
		if(isOrganization)then{
	//		self.map OrganizationType(result,context);
			entityRepresentation.map OrganizationType(result,context);
		}else{
			result.addEntityPerson(entityRepresentation.map PersonType(context));
		}endif;
	};	
}
//mapping UML::InstanceSpecification::PersonType(inout entityType:NC::EntityType,context:UML::NamedElement):NC::PersonType{
mapping UML::InstanceSpecification::PersonType(context:UML::NamedElement):NC::PersonType{
	//entityType.addEntityPerson(result);
	personName+=self.getNames().map PersonNameType(context);
}
	
mapping UML::InstanceSpecification::OrganizationType(inout entityType:NC::EntityType,context:UML::NamedElement):NC::OrganizationType{
	// entityRepresentation
	//entityType.entityOrganization+=result;
	entityType.addEntityOrganization(result);
//	organizationName+=self.getMpdASName().map TextType(context);
	organizationName+=self.getNames().map TextType(context);
	self.getOrganizationPrimaryContactInformation()->forEach(poc){
		poc.map ContactInformationType(result,context);
		//as.pOC+=POC;
	};
}
mapping UML::InstanceSpecification::ContactInformationType(inout organizationType:NC::OrganizationType,context:UML::NamedElement):NC::ContactInformationType{
		// TODO: point of contact information  OrganizationPrimaryContactInformation?
		// TODO: POC, pOCName,pOCEmail, pOCTelephone
		/*
		var POC:CAT::POCType=new CAT::POCType();
		POC.pOCName:=poc.getPOCName();
		POC.pOCEmail:=poc.getPOCEmail();
		POC.pOCTelephone:=poc.getPOCTelephone();
		*/
		organizationType.organizationPrimaryContactInformation+=result;
		/*
		self.getPOCName().map ContactEntityType(result,context);
		self.getPOCEmail().map ProxyString(self,'contactEmailID').addContactEmailID(result);
		self.getPOCTelephone()
			.map ProxyString(self,'contactTelephoneNumber')
			.map TelephoneNumberType().addContactTelephoneNumber(result);
			*/
		// find max length of sequences, add as many ContactMeans to include all 	
		var contactEmailID:Sequence(String):=self.contactEmailID();
		var contactMailingAddress:Sequence(String):=self.contactMailingAddress();
		var contactTelephoneNumber:Sequence(String):=self.contactTelephoneNumber();
		var contactWebsiteURI:Sequence(String):=self.contactWebsiteURI();
//		contactMeans+=contactEmailID.map ContactEmailID(result);
		/*
		var maxSize:Integer=contactEmailID->size().max(
			contactMailingAddress->size().max(
			contactTelephoneNumber->size().max(
			contactWebsiteURI->size())));
		var index:Integer=1;
		while(index<=maxSize){
			contactMeans+=result.map ContactMeans(index,contactEmailID,contactMailingAddress,contactTelephoneNumber,contactWebsiteURI);
			index:=index+1;
		};
		*/
		//contactEmailID->forEach(value){result.oclAsType(CMOF::EObject).add('contactMeans','contactEmailID',value);};
		contactEmailID.map ProxyString(self,'contactEmailID').addContactEmailID(result);
//		contactMailingAddress.map ProxyString(self,'contactMailingAddress').map AddressType().addContactMailingAddress(result);
		contactMailingAddress.map TextType(self).map AddressType(self).addContactMailingAddress(result);
		contactTelephoneNumber.map ProxyString(self,'contactTelephoneNumber').map TelephoneNumberType().addContactTelephoneNumber(result);
		contactWebsiteURI.map ProxyAnyURI(self,'contactWebsiteURI').addContactWebsiteURI(result);
		
		contactEntity+=self.getContactEntity().map ContactEntity(result,context);
		contactResponder+=self.getContactResponder().map PersonType(context);
	
		/*
          <xs:element ref="nc:ContactMeans" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element ref="nc:ContactEntity" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element ref="nc:ContactResponder" minOccurs="0" maxOccurs="unbounded"/>
			*/
}
	
	
mapping UML::InstanceSpecification::ContactEntity(inout contactInformationType:NC::ContactInformationType,context:UML::NamedElement):NC::EntityType{
	contactInformationType.contactEntity+=result;
	
		var isOrganization:Boolean=self.classifier.name->includes('OrganizationType');
		log('ContactEntity '+isOrganization.repr()+', '+self.repr());
		if(isOrganization)then{
	//		self.map OrganizationType(result,context);
			log('ContactEntity organization '+result.repr()+', '+context.repr());
			self.map OrganizationType(result,context);
		}else{
			result.addEntityPerson(self.map PersonType(context));
		}endif;
	
}



mapping NC::TextType::AddressType(context:UML::NamedElement):NC::AddressType{
//	addressFullText=self.map TextType(context);
	addressFullText+=self;
}

mapping PROXY::_String::TelephoneNumberType():NC::TelephoneNumberType{
	result.addFullTelephoneNumberType(self.map FullTelephoneNumberType());
}
mapping PROXY::_String::FullTelephoneNumberType():NC::FullTelephoneNumberType{
	telephoneNumberFullID:=self;
}
mapping String::ContactEntityType(inout mpdInformationType:NC::ContactInformationType,context:UML::NamedElement):NC::EntityType{
	mpdInformationType.contactEntity+=result;
	self.map ContactOrganizationType(result,context);
}
mapping String::ContactOrganizationType(inout entityType:NC::EntityType,context:UML::NamedElement):NC::OrganizationType{
	// entityRepresentation
	//entityType.entityOrganization+=result;
	entityType.addEntityOrganization(result);
	organizationName+=self.map TextType(context);
}

mapping String::ProxyAnyURI(context:Stdlib::Element,feature:String):PROXY::AnyURI{
	value:=self;
}
	
mapping String::ProxyString(context:Stdlib::Element,feature:String):PROXY::_String{
	value:=self;
}
mapping String::ProxyDate(context:Stdlib::Element,feature:String):PROXY::Date{
//	value:=self.toDate().oclAsType(XSD::Date);
	//value:=self.oclAsType(type::Date);
	result.setProxyDateValue(self);
}
//mapping UML::Dependency::ModelPackageDescriptionRelationship(inout md:CAT::MetadataType):CAT::RelationshipType
mapping UML::Dependency::ModelPackageDescriptionRelationship(inout md:CAT::MPDInformationType):CAT::RelationshipType@cat
	when{self.isStereotypeApplied(NIEMModelPackageDescriptionRelationshipStereotype)}
{
		md.relationship+=result;
//if(false)then{// debug test		
		var relationshipType:Stdlib::Element=self.getStereotypeApplication(NIEMModelPackageDescriptionRelationshipStereotype).oclAsType(Stdlib::Element);
//		descriptionText:=relationshipType.getRelationshipDescriptionText();
//	descriptionText:=relationshipType.getRelationshipDescriptionText().map TextType(self);
	var descriptionTextValue:String=relationshipType.getDescriptionText();
	descriptionText:=descriptionTextValue.map TextType(self);
		var code:String=relationshipType.getRelationshipCode();
		relationshipCode:=switch{
			case(code='versionOf') CAT::RelationshipCodeSimpleType::versionOf;
			case(code='specializes') CAT::RelationshipCodeSimpleType::specializes;
			case(code='generalizes') CAT::RelationshipCodeSimpleType::generalizes;
			case(code='supersedes') CAT::RelationshipCodeSimpleType::supersedes;
			case(code='deprecates') CAT::RelationshipCodeSimpleType::deprecates;
			case(code='adapts') CAT::RelationshipCodeSimpleType::adapts;
			case(code='updates') CAT::RelationshipCodeSimpleType::updates;
			case(code='derives_from') CAT::RelationshipCodeSimpleType::derivesFrom;
			else CAT::RelationshipCodeSimpleType::conformsTo;
			};
//}endif;		
	self.supplier->forEach(supplier){
		if(supplier.oclIsKindOf(UML::Package))then{
			resourceURI:=supplier.oclAsType(UML::Package).URI;
			//setResourceURI(inout relationship:CAT::RelationshipType);
		}endif;
	};
		
}

//mapping UML::Usage::AbstractModelPackageDescriptionFile(inout catalog:CAT::CatalogType):CAT::FileType
mapping UML::Usage::AbstractModelPackageDescriptionFile(inout catalog:Stdlib::Element):CAT::FileType
	disjuncts 
		UML::Usage::ApplicationInfo,
		UML::Usage::BusinessRulesArtifact,
		UML::Usage::ConformanceAssertion,
		UML::Usage::ConformanceReport,
		UML::Usage::Documentation,
		//UML::Usage::ExtensionSchemaDocumentFile,
		//UML::Usage::ExternalSchemaDocumentFile,
		UML::Usage::File,
		UML::Usage::IEPSampleXMLDocument,
		UML::Usage::MPDChangeLog,
		UML::Usage::ReadMe,
		//UML::Usage::ReferenceSchemaDocumentFile,
		UML::Usage::RelaxNGSchema,
		UML::Usage::RequiredFile,
		UML::Usage::SchematronSchema,
		//UML::Usage::SubsetSchemaDocumentFile,
		UML::Usage::Wantlist,
		UML::Usage::XMLCatalog,
		//UML::Usage::XMLSchemaDocument,
		UML::Usage::AbstractXMLSchemaDocument,
		UML::Usage::ModelPackageDescriptionFile
	{}
mapping UML::Usage::AbstractXMLSchemaDocument(inout catalog:Stdlib::Element):CAT::FileType
	disjuncts 
		UML::Usage::ExtensionSchemaDocumentFile,
		UML::Usage::ExternalSchemaDocumentFile,
		UML::Usage::ReferenceSchemaDocumentFile,
		UML::Usage::SubsetSchemaDocumentFile,
		UML::Usage::XMLSchemaDocument
	{}
mapping UML::Usage::ExternalSchemaDocumentFile(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ExternalSchemaDocument')}
{
	catalog.addExternalSchemaDocument(result);
}
mapping UML::Usage::ExtensionSchemaDocumentFile(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ExtensionSchemaDocument')}
{
	catalog.addExtensionSchemaDocument(result);
}
mapping UML::Usage::ReferenceSchemaDocumentFile(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ReferenceSchemaDocument')}
{
	catalog.addReferenceSchemaDocument(result);
}
	
mapping UML::Usage::SubsetSchemaDocumentFile(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('SubsetSchemaDocument')}
{
	catalog.addSubsetSchemaDocument(result);
}
mapping UML::Usage::XMLCatalog(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('XMLCatalog')}
	{
	catalog.addXMLCatalog(result);
}	
mapping UML::Usage::XMLSchemaDocument(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('XMLSchemaDocument')}
	{
	catalog.addXMLSchemaDocument(result);
}	
mapping UML::Usage::RequiredFile(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('RequiredFile')}
	{
	catalog.addRequiredFile(result);
}	
mapping UML::Usage::SchematronSchema(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('SchematronSchema')}
	{
	catalog.addSchematronSchema(result);
}	
mapping UML::Usage::Wantlist(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('Wantlist')}
	{
	catalog.addWantlist(result);
}	
mapping UML::Usage::MPDChangeLog(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('MPDChangeLog')}
	{
	catalog.addMPDChangeLog(result);
}	
mapping UML::Usage::ReadMe(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ReadMe')}
	{
	catalog.addReadMe(result);
}	
mapping UML::Usage::RelaxNGSchema(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('RelaxNGSchema')}
	{
	catalog.addRelaxNGSchema(result);
}	
mapping UML::Usage::Documentation(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('Documentation')}
	{
	catalog.addDocumentation(result);
}	
mapping UML::Usage::File(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('File')}
	{
	catalog.addFile(result);
}	
mapping UML::Usage::IEPSampleXMLDocument(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('IEPSampleXMLDocument')}
	{
	catalog.addIEPSampleXMLDocument(result);
}	
mapping UML::Usage::BusinessRulesArtifact(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('BusinessRulesArtifact')}
	{
	catalog.addBusinessRulesArtifact(result);
}	
mapping UML::Usage::ConformanceAssertion(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ConformanceAssertion')}
	{
	catalog.addConformanceAssertion(result);
}	
mapping UML::Usage::ConformanceReport(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ConformanceReport')}
	{
	catalog.addConformanceReport(result);
}	
	
	
mapping UML::Usage::ApplicationInfo(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('ApplicationInfo')}
	{
	catalog.addApplicationInfo(result);
}	
mapping UML::Usage::ModelPackageDescriptionFileCommon(inout catalog:Stdlib::Element):CAT::FileType@cat
	{
	var schemaPackage:UML::NamedElement=self.supplier->asSequence()->first();
//	relativePathName:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
	pathURI:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMModelPackageDescriptionFileStereotype).oclAsType(Stdlib::Element);
//	var pimmpd:Stdlib::Element=self.client->asSequence()->first().oclAsType(Stdlib::Element);
//	var pimmpd:UML::InstanceSpecification=self.client->asSequence()->first().oclAsType(UML::InstanceSpecification);
	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMFileType).oclAsType(Stdlib::Element);
	var explicitRelativePathName:String =pimmpd.getFileTypeRelativePathName();
	if(not(explicitRelativePathName.oclIsUndefined()) and (explicitRelativePathName<>''))then{
//		relativePathName:=explicitRelativePathName;
		pathURI:=explicitRelativePathName;
		
	}endif;
//	descriptionText:=pimmpd.getFileDescriptionText();
//	descriptionText:=pimmpd.getFileDescriptionText().map TextType(self);
	descriptionText:=pimmpd.getDescriptionText().map TextType(self);
	id:=self.getFileId();
//	externalURI:=pimmpd.getFileTypeExternalURI();
	externalURI:=pimmpd.getExternalURI();
	mimeMediaTypeText:=pimmpd.getMimeMediaTypeText();
	// not in NIEM3
	//natureURI:=pimmpd.getFileTypeNatureURI();
	//purposeURI:=pimmpd.getFileTypePurposeURI();
}
mapping UML::Usage::ModelPackageDescriptionFile(inout catalog:Stdlib::Element):CAT::FileType@cat
	inherits UML::Usage::ModelPackageDescriptionFileCommon
	when{self.stereotypedBy('FileType')}
	{
	catalog.addCatalogFile(result);
}
/*
mapping UML::Usage::FileSetFile(inout fileSet:CAT::FileSetType):CAT::FileType@cat{
	fileSet.addFileSetFile(result);
	var schemaPackage:UML::NamedElement=self.supplier->asSequence()->first();
	pathURI:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
	var pimmpd:Stdlib::Element=self.getStereotypeApplication(NIEMFileType);
	var explicitRelativePathName:String =pimmpd.getFileTypeRelativePathName();
	if(not(explicitRelativePathName.oclIsUndefined()) and (explicitRelativePathName<>''))then{
		pathURI:=explicitRelativePathName;
	}endif;
	descriptionText:=pimmpd.getDescriptionText().map TextType(self);
	
	id:=self.getFileId();
	externalURI:=pimmpd.getExternalURI();
}
*/
/*
mapping UML::Usage::SubsetSchemaDocument(inout fileSet:CAT::SchemaDocumentSetType):CAT::FileType@cat
	inherits UML::Usage::FileSetFile
{
//	fileSet.xMLSchemaDocument+=result;
//	fileSet.artifactOrArtifactSet+=result;
	fileSet.oclAsType(CMOF::EObject).add('artifactOrArtifactSetGroup','subsetSchemaDocument',result.oclAsType(CMOF::EObject));
}
*/
//mapping UML::Component::SchemaDocumentSetType(inout catalog:CAT::CatalogType):CAT::SchemaDocumentSetType
//mapping UML::Component::SchemaDocumentSetType(inout catalog:CAT::MPDType):CAT::SchemaDocumentSetType
mapping UML::InstanceSpecification::SchemaDocumentSetType(inout catalog:CAT::MPDType):CAT::SchemaDocumentSetType@cat
	inherits UML::InstanceSpecification::ModelPackageDescriptionFileSet
{
	catalog.addSchemaDocumentSet(result);
//	var pimmpd:Stdlib::Element=self.getStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var pimmpd:UML::InstanceSpecification=self;
	pimmpd.getMpdFileUsages().map SubsetSchemaDocument(result);	
	//self.clientDependency->select(e|e.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype))
	//	.oclAsType(UML::Usage).map SubsetSchemaDocument(result);
}
//mapping UML::Component::ModelPackageDescriptionFileSet(inout catalog:CAT::MPDType):CAT::FileSetType{
mapping UML::InstanceSpecification::ModelPackageDescriptionFileSet(inout catalog:CAT::MPDType):CAT::FileSetType@cat{
	catalog.addCatalogFileSet(result);
//	self.elementImport.importedElement->select(e|e.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype))
//		.oclAsType(UML::Usage)->forEach(fileType){result.addFileSetFiles(fileType.getFileId());};
//	self.elementImport.importedElement->select(e|e.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype))
//		.oclAsType(UML::Usage)->forEach(fileType){result.addFileSetFiles(fileType.getFileId());};
//	self.oclAsType(Stdlib::Element).getMpdFileUsages()->forEach(fileType){result.addFileSetFiles(fileType.getFileId());};	
	self.getMpdFileUsages()->forEach(fileType){result.addFileSetFiles(fileType.getFileId());};	
//	self.clientDependency->select(e|e.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype))
//		.oclAsType(UML::Usage).map ModelPackageDescriptionFile(result);
		

//	var pimMpdFileSetStereotypeInstance:Stdlib::Element=self.getStereotypeApplication(NIEMModelPackageDescriptionFileSetStereotype).oclAsType(Stdlib::Element);
//	var pimMpdFileSetStereotypeInstance:Stdlib::Element=self.oclAsType(Stdlib::Element);
	var pimMpdFileSetStereotypeInstance:UML::InstanceSpecification=self.oclAsType(UML::InstanceSpecification);
	
	// not in NIEM3
	//natureURI:=natureFilesetURI;
	//purposeURI:=pimMpdFileSetStereotypeInstance.getFileSetTypePurposeCode();
	id:='fs_'+self.getFileId();
//	externalURI:=pimMpdFileSetStereotypeInstance.getFileSetExternalURI();
	externalURI:=pimMpdFileSetStereotypeInstance.getExternalURI();
	
//	var ncDescriptionText:NC::DescriptionTextType=new NC::DescriptionTextType();
//	descriptionText:=pimMpdFileSetStereotypeInstance.getFileSetDescriptionText();
//	descriptionText:=pimMpdFileSetStereotypeInstance.getFileSetDescriptionText().map TextType(self);
	descriptionText:=pimMpdFileSetStereotypeInstance.getDescriptionText().map TextType(self);

}
/*
mapping 	UML::NamedElement::FolderType(inout catalog:CAT::CatalogType,mpdRootPackage:UML::Model):CAT::FolderType
{
	catalog.addCatalogFolder(result);
	relativePathName:=self.toRelativePathName(mpdRootPackage,result);
}
*/
/* not used
mapping 	UML::NamedElement::FolderType(inout catalog:CAT::MPDType,mpdRootPackage:UML::Model):CAT::SchemaDocumentSetType
{
	catalog.addSchemaDocumentSet(result);
	pathURI:=self.toRelativePathName(mpdRootPackage,result);
}
*/
////////////////////////////////////////////////////extra
helper WANTLIST::AttributeType::setWantlistAttributeName(namespace:String,localPart:String,prefix:String){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistAttributeName');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"namespace".setAnnotationDetail(annotation,namespace);
	"localPart".setAnnotationDetail(annotation,localPart);
	"prefix".setAnnotationDetail(annotation,prefix);
	blackboxHook.eAnnotations+=annotation;
	return ;
	}
helper WANTLIST::ElementType::setWantlistElementName(namespace:String,localPart:String,prefix:String){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistElementName');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"namespace".setAnnotationDetail(annotation,namespace);
	"localPart".setAnnotationDetail(annotation,localPart);
	"prefix".setAnnotationDetail(annotation,prefix);
	blackboxHook.eAnnotations+=annotation;
	return ;
	}
helper WANTLIST::TypeType::setWantlistTypeName(namespace:String,localPart:String,prefix:String){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistTypeName');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"namespace".setAnnotationDetail(annotation,namespace);
	"localPart".setAnnotationDetail(annotation,localPart);
	"prefix".setAnnotationDetail(annotation,prefix);
	blackboxHook.eAnnotations+=annotation;
	return ;
	}
///////////////////////
helper WANTLIST::AttributeInTypeType::setWantlistAttributeTypeName(namespace:String,localPart:String,prefix:String){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistAttributeTypeName');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"namespace".setAnnotationDetail(annotation,namespace);
	"localPart".setAnnotationDetail(annotation,localPart);
	"prefix".setAnnotationDetail(annotation,prefix);
	blackboxHook.eAnnotations+=annotation;
	return ;
	}
helper WANTLIST::ElementInTypeType::setWantlistElementTypeName(namespace:String,localPart:String,prefix:String){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistElementTypeName');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"namespace".setAnnotationDetail(annotation,namespace);
	"localPart".setAnnotationDetail(annotation,localPart);
	"prefix".setAnnotationDetail(annotation,prefix);
	blackboxHook.eAnnotations+=annotation;
	return ;
	}
helper WANTLIST::UnionMemberType::setWantlistUnionMemberTypeName(namespace:String,localPart:String,prefix:String){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistUnionMemberTypeName');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"namespace".setAnnotationDetail(annotation,namespace);
	"localPart".setAnnotationDetail(annotation,localPart);
	"prefix".setAnnotationDetail(annotation,prefix);
	blackboxHook.eAnnotations+=annotation;
	return ;
	}
helper WANTLIST::ElementInTypeType::setWantlistElementMaxOccurs(maxOccurs:Integer){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('setWantlistElementMaxOccurs');
	annotation._references+=self.oclAsType(CMOF::EObject);
	"maxOccurs".setAnnotationDetail(annotation,maxOccurs.repr());
	blackboxHook.eAnnotations+=annotation;
	return ;
	}


helper 	XSD::XSDSchema::wantlistAttribute(inout topWantList:WANTLIST::WantListType){// EXTRA
	var prefix:String=self.getWantlistPrefix();
	if(prefix.oclIsUndefined()) then {return;}endif;
	self.attributeDeclarations->select(a|a.targetNamespace=self.targetNamespace)
	->forEach(attribute){
		var attributeType:WANTLIST::AttributeType=new WANTLIST::AttributeType@wantlist();
		//attributeType.qualifier:=prefix+':'+attribute.name;
		attributeType.setWantlistAttributeName(self.targetNamespace,attribute.name,prefix);
		topWantList.attribute+=attributeType;
	};

	// add elements from schema to wantList
	// AttributeType, ElementType, TypeType
	// lets see how we are doing before more
	return;
}
helper 	XSD::XSDSchema::wantlistElement(inout topWantList:WANTLIST::WantListType){// EXTRA
	var prefix:String=self.getWantlistPrefix();
	if(prefix.oclIsUndefined()) then {log("No wantlist for non-reference schema "+self.targetNamespace);return;}endif;
	self.elementDeclarations
	->select(a|a.targetNamespace=self.targetNamespace)
	->forEach(element){
		if(element.name.oclIsUndefined())then{
			log("ERROR:wantlist element has no name in schema "+self.targetNamespace);
		}else{
		var elementType:WANTLIST::ElementType=new WANTLIST::ElementType@wantlist();
//		elementType.qualifier:=prefix+':'+element.name;
		elementType.setWantlistElementName(self.targetNamespace,element.name,prefix);
		elementType.isReference:=element.name.endsWith('Reference');
		topWantList.element+=elementType;
		}endif;
	};
	return;
}
helper 	XSD::XSDSchema::wantlistType(inout topWantList:WANTLIST::WantListType){// EXTRA
	var prefix:String=self.getWantlistPrefix();
	if(prefix.oclIsUndefined()) then {return;}endif;
	self.typeDefinitions
	->select(a|a.targetNamespace=self.targetNamespace)
	->select(t|not(t.name.oclIsUndefined()))
	->forEach(type){
	//log('wantlistType '+type.repr());
		var typeType:WANTLIST::TypeType=new WANTLIST::TypeType@wantlist();
		//typeType.qualifier:=prefix+':'+type.name;
		typeType.setWantlistTypeName(self.targetNamespace,type.name,prefix);
		topWantList.type+=typeType;
		typeType.isRequested:=false;
		if(type.oclIsKindOf(XSD::XSDComplexTypeDefinition))then{
			var complexType:XSD::XSDComplexTypeDefinition=type.oclAsType(XSD::XSDComplexTypeDefinition);
			// AttributeInType
			complexType.attributeContents->forEach(attributeContent){
				if(attributeContent.oclIsKindOf(XSD::XSDAttributeUse))then{
					var attributeUse:XSD::XSDAttributeUse=attributeContent.oclAsType(XSD::XSDAttributeUse);
					var resolvedAttribute:XSD::XSDAttributeDeclaration=attributeUse.attributeDeclaration;
					var prefix2:String=resolvedAttribute.targetNamespace.getWantlistPrefix();
					if(not(prefix2.oclIsUndefined()))then{
						var attributeTypeType:WANTLIST::AttributeInTypeType=new WANTLIST::AttributeInTypeType@wantlist();
						attributeTypeType.setWantlistAttributeTypeName(resolvedAttribute.targetNamespace,resolvedAttribute.name,prefix2);
						typeType.attributeInType+=attributeTypeType;
					}endif;
				}endif;
			};
			// ElementInType
			var content:XSD::XSDComplexTypeContent=complexType.content;
			if(not(content.oclIsUndefined()) and content.oclIsKindOf(XSD::XSDParticle))then{
				var particle:XSD::XSDParticle=content.oclAsType(XSD::XSDParticle);
				particle.wantlistElementInType(typeType);
			}endif;

		}else{
			var simpleType:XSD::XSDSimpleTypeDefinition=type.oclAsType(XSD::XSDSimpleTypeDefinition);
			// Facet
			simpleType.facetContents->forEach(facet){
				var facetType:WANTLIST::FacetType=new WANTLIST::FacetType@wantlist();
				var facetTypeType:WANTLIST::FacetFacetType=switch{
					case(facet.facetName='minExclusive')WANTLIST::FacetFacetType::minExclusive;
					case(facet.facetName='maxExclusive')WANTLIST::FacetFacetType::maxExclusive;
					case(facet.facetName='maxInclusive')WANTLIST::FacetFacetType::maxInclusive;
					case(facet.facetName='totalDigits')WANTLIST::FacetFacetType::totalDigits;
					case(facet.facetName='fractionDigits')WANTLIST::FacetFacetType::fractionDigits;
					case(facet.facetName='length')WANTLIST::FacetFacetType::length;
					case(facet.facetName='minLength')WANTLIST::FacetFacetType::minLength;
					case(facet.facetName='maxLength')WANTLIST::FacetFacetType::maxLength;
					case(facet.facetName='enumeration')WANTLIST::FacetFacetType::enumeration;
					case(facet.facetName='whiteSpace')WANTLIST::FacetFacetType::whiteSpace;
					case(facet.facetName='pattern')WANTLIST::FacetFacetType::pattern;
					
				/*
					case(facet.facetName='minExclusive'){
						WANTLIST::FacetFacetType::minExclusive;
					} ;
					case(facet.facetName='maxExclusive'){
						WANTLIST::FacetFacetType::maxExclusive;
					} ;
					case(facet.facetName='maxInclusive'){
						WANTLIST::FacetFacetType::maxInclusive;
					} ;
					case(facet.facetName='totalDigits'){
						WANTLIST::FacetFacetType::totalDigits;
					} ;
					case(facet.facetName='fractionDigits'){
						WANTLIST::FacetFacetType::fractionDigits;
					} ;
					case(facet.facetName='length'){
						WANTLIST::FacetFacetType::length;
					} ;
					case(facet.facetName='minLength'){
						WANTLIST::FacetFacetType::minLength;
					} ;
					case(facet.facetName='maxLength'){
						WANTLIST::FacetFacetType::maxLength;
					} ;
					case(facet.facetName='enumeration'){
						WANTLIST::FacetFacetType::enumeration;
					} ;
					case(facet.facetName='whiteSpace'){
						WANTLIST::FacetFacetType::whiteSpace;
					} ;
					case(facet.facetName='pattern'){
						WANTLIST::FacetFacetType::pattern;
					} ;
					*/
				};
				facetType.facet:=facetTypeType;
				facetType.value:=facet.lexicalValue;
				typeType.facet+=facetType;
			};
			// UnionMember
			simpleType.memberTypeDefinitions->forEach(member){
				var prefix2:String=member.targetNamespace.getWantlistPrefix();
				if(not(prefix2.oclIsUndefined()))then{
					var unionMemberType:WANTLIST::UnionMemberType=new WANTLIST::UnionMemberType@wantlist();
					unionMemberType.setWantlistUnionMemberTypeName(member.targetNamespace,member.name,prefix2);
					typeType.unionMember+=unionMemberType;
				}endif;
			};
		}endif;

	};
	return;
}
helper 	XSD::XSDParticle::wantlistElementInType(inout typeType:WANTLIST::TypeType){// EXTRA
				var particleContent:XSD::XSDParticleContent=self.content;
				if((particleContent=null)or particleContent.oclIsUndefined()) then {return;}endif;
				if(particleContent.oclIsKindOf(XSD::XSDElementDeclaration))then{
					var resolvedElementDeclaration:XSD::XSDElementDeclaration=particleContent.oclAsType(XSD::XSDElementDeclaration).resolvedElementDeclaration;
					if((resolvedElementDeclaration=null)or resolvedElementDeclaration.oclIsUndefined()) then {return;}endif;
					//log('wantlistElementInType '+resolvedElementDeclaration.repr());
					var prefix2:String=resolvedElementDeclaration.targetNamespace.getWantlistPrefix();
					if(not(prefix2.oclIsUndefined()))then{
						var elementTypeType:WANTLIST::ElementInTypeType=new WANTLIST::ElementInTypeType@wantlist();
						elementTypeType.setWantlistElementTypeName(resolvedElementDeclaration.targetNamespace,resolvedElementDeclaration.name,prefix2);
						elementTypeType.isReference:=resolvedElementDeclaration.name.endsWith('Reference');
						elementTypeType.minOccurs:=self.minOccurs;
                        //var maxOccursValue:WANTLIST::AllNNIMember1=WANTLIST::AllNNIMember1::unbounded;
//                        elementTypeType.maxOccurs:=if(self.maxOccurs<0) then 'unbounded' else self.maxOccurs endif;
                        //elementTypeType.maxOccurs:=if(self.maxOccurs<0) then WANTLIST::AllNNIMember1::unbounded else self.maxOccurs.oclAsType(OclAny) endif;
                        elementTypeType.setWantlistElementMaxOccurs(self.maxOccurs);
						typeType.elementInType+=elementTypeType;
					}endif;

				}else{
					if(particleContent.oclIsKindOf(XSD::XSDModelGroup))then{
						particleContent.oclAsType(XSD::XSDModelGroup).contents.wantlistElementInType(typeType);
				//    <xsd:attribute name="choice" use="optional" type="w:PositiveIntegerListType"/>
					}endif;
				}endif;
				return;
}

helper 	String::getWantlistPrefix():String{// EXTRA
	// add prefixes
	var targetNamespace:String=self;
	prefixToNamespace->forEach(p){
		if(p.namespace=targetNamespace)then{return p.prefix;}endif;
	};
	return null;
	}
helper 	XSD::XSDSchema::getWantlistPrefix():String{// EXTRA
	return self.targetNamespace.getWantlistPrefix();
	}
helper 	wantlistPrefixes(inout wantlistDocument:WANTLIST::DocumentRoot){// EXTRA
	// add prefixes
	prefixToNamespace->forEach(p){
		wantlistDocument.addXmlns(p.prefix,p.namespace);
	};
	return;
	}
helper 	WANTLIST::DocumentRoot::addXmlns(in prefix:String,in namespace:String){// EXTRA
	// add prefixes
	var prefixMaps:OrderedSet(CMOF::EStringToStringMapEntry)=self.xMLNSPrefixMap;
	var prefixMap:CMOF::EStringToStringMapEntry=new CMOF::EStringToStringMapEntry();
	prefixMap.key:=prefix;
	prefixMap.value:=namespace;
	prefixMaps+=prefixMap;
	return;
}
