/*
NIEM UML 
Copyright ï¿½ 2011, ModelDriven.org and Tom Digre, all rights reserved worldwide.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see http://www.gnu.org/licenses/gpl-3.0-standalone.html.

There are also commercial licenses available for this software.
Contact ModelDriven.org for more information.
*/
import NIEMmpdartifact2model;

//modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.4.1';

//modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.5';
modeltype UML uses 'http://www.omg.org/spec/UML/20131001';
//modeltype ECORE  uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype CMOF  uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';
//modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/1.0/';
modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/3.0/';
//modeltype CAT  uses 'urn:oasis:names:tc:entity:xmlns:xml:catalog';
modeltype NC uses 'http://release.niem.gov/niem/niem-core/3.0/';
modeltype PROXY uses 'http://release.niem.gov/niem/proxy/xsd/3.0/';


transformation mpd2pim(in cat:CAT,inout pimUml:UML,inout blackboxAdapter:CMOF)
	extends transformation NIEMmpdartifact2model(inout UML)
		;
	main() {
	mpd2pim_run();
}	
property catalog:CAT::CatalogType=null;
property documentRoot:CAT::DocumentRoot=null;
property schemaTargetNamespaces:Sequence(Tuple(schema:UML::Package,targetNamespace:String)) = Sequence{};
property allSchemaTargetNamespaces:Sequence(Tuple(schema:UML::Package,targetNamespace:String)) = Sequence{};
property instanceRefs:Sequence(Tuple(instanceValue:UML::InstanceValue,ref:String)) = Sequence{};
property metadataRefs:Sequence(Tuple(instanceValue:UML::InstanceValue,ref:String)) = Sequence{};
	
helper mpd2pim_run() {
		log('mpd2pim starting now '+pimUml.repr());
		blackboxHook:=blackboxAdapter.objectsOfType(CMOF::EPackage)->asSequence()->first();
		documentRoot:=cat.objectsOfType(CAT::DocumentRoot)->asSequence()->first();
		catalog:=cat.objectsOfType(CAT::CatalogType)->asSequence()->first();
		rootDirectory:=documentRoot.oclAsType(CMOF::EObject).getRootFileName();
		log('mpd2pim starting NIEMmpd2pim_run root at '+rootDirectory);
		expandSchemaContent:=false;
		NIEMmpd2pim_run();
		// we could try to populate xml instances now
		gatherAllSchemas(mpdRootPackage);
		// <<mpdFile>> no longer exists, we need to consider Usages owned by component
if(true)then{log('suppress sample instance documents');}else{		
		mpdComponent.importSampleInstanceDocuments();
}endif;		
		/*
		mpdComponent.clientDependency
		->select(d|
			d.isStereotypeApplied(NIEMModelPackageDescriptionFileStereotype) 
			and (d.getStereotypeApplication(NIEMModelPackageDescriptionFileStereotype).getFileTypePurposeURI()=purposeSampleInstanceURI)
			)
		->forEach(mpdFile){
			mpdFile.supplier->select(s|s.oclIsKindOf(Package)).oclAsType(Package)->forEach(xmlInstancePackage){
				var relativePathName:String=xmlInstancePackage.getMpdRelativePathForPackage(mpdRootPackage);
				var domDocument:OclAny=catalog.oclAsType(CMOF::EObject).getDocumentAtRelativeURI(relativePathName);
				log('sample instance '+xmlInstancePackage.qualifiedName+', '+relativePathName+', '+domDocument.repr());
				domDocument.xmlInstanceDocumentTopElement(xmlInstancePackage);
			};
		};
		*/
		// try to put schemas into base-xsd based on some niem 2.1 conventions
		/* accept what you are given
		mpdRootPackage.nestedPackage
			->select(p|(p.name='Schema')or(p.name='artifacts'))
			->forEach(s){s.name:='base-xsd';};
		*/	
		mapInit();
		// remove component if reference model
		log('mpd2pim end ');
	}
///////////////////
// TODO
// UML Packages representing sample document instances; as referenced from mpd catalog;
// assumes magic draw FileType instances can be clients of dependencies
//  but we also need to find all those FileType instances --- via <<Mpd>> on component
//	can we assume that all dependencies owned by component?
//  break this into recover of fileTypes, break down fileTypes to xmlDocs, find dependencies
//		later we can migrate to instances
//		
//helper UML::Component::importSampleInstanceDocuments(){
helper UML::InstanceSpecification::importSampleInstanceDocuments(){
//	self.getSampleInstanceFileTypes().clientDependency.supplier
	self.clientDependency->select(d|d.getAppliedStereotypeInstances()->exists(s|s.isInstanceOf('XMLSchemaDocument'))).supplier
//	self.clientDependency->select(d|d.appliedStereotype->exists(s|s.isInstanceOf('XMLSchemaDocument'))).supplier
		->select(s|s.oclIsKindOf(Package)).oclAsType(Package)
		->forEach(xmlInstancePackage){
				var relativePathName:String=xmlInstancePackage.getMpdRelativePathForPackage(mpdRootPackage);
				var domDocument:OclAny=catalog.oclAsType(CMOF::EObject).getDocumentAtRelativeURI(relativePathName);
				log('sample instance '+xmlInstancePackage.qualifiedName+', '+relativePathName+', '+domDocument.repr());
				domDocument.xmlInstanceDocumentTopElement(xmlInstancePackage);
			};
	return;	
}	
//helper UML::Component::getSampleInstanceFileTypes():Set(UML::InstanceSpecification)
//	=self.getFileTypes()->select(t|t.isInstanceOf('XMLSchemaDocument'));
	

helper 		gatherAllSchemas(mpdRootPackage:UML::Package){
		mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isStereotypeApplied(NIEMSchemaStereotype))
			->forEach(schemaPackage){
				var schemaTuple:Tuple(schema:UML::Package,
						targetNamespace:String)=
						Tuple{schema:UML::Package=schemaPackage,
						targetNamespace:String=schemaPackage.getStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element).getSchemaTargetNamespace()};
				log('Schema proxy for '+schemaTuple.targetNamespace+', '+schemaTuple.schema.qualifiedName);		
				allSchemaTargetNamespaces+=schemaTuple;		
			};
		log('schemaTuple proxies '+allSchemaTargetNamespaces->size().repr());	
		return;
}

helper OclAny::xmlInstanceDocumentTopElement(inout xmlInstancePackage:Package){
	var topLevelElement:Property=self.getTopLevelElement();
	if(topLevelElement.oclIsUndefined())then{
		log('ERROR: failed to located top level element '+self.getElementNamespace()+" : "+self.getElementName());
		return;
	}endif;
	var  instanceSpecification:InstanceSpecification=new InstanceSpecification();
	instanceSpecification.name:=xmlInstancePackage.name;
	instanceSpecification.classifier+=topLevelElement.classifier;
	xmlInstancePackage.packagedElement+=instanceSpecification;
	var  slot:Slot=new Slot();
	instanceSpecification.slot+=slot;
	// definedFeature from an exchange
	
	slot.definingFeature:=topLevelElement;
	var instanceValue:InstanceValue=new InstanceValue();
	slot.value+=instanceValue;
	var instance:InstanceSpecification=new InstanceSpecification();
	instanceValue.instance:=instance;
	instance.classifier+=topLevelElement.type.oclAsType(Classifier);
	xmlInstancePackage.packagedElement+=instance;
	// content : in conjunction with feature type
	instanceRefs:= Sequence{};
	metadataRefs:= Sequence{};
	/*
	*/
	self.xmlInstanceDocumentElement(instance,topLevelElement.type.oclAsType(Classifier));
	// now resolve references
	instanceRefs->forEach(instanceRef){
		var id:String=instanceRef.ref;
		xmlInstancePackage.packagedElement->select(i|(i.name=id) and i.oclIsKindOf(InstanceSpecification)).oclAsType(InstanceSpecification)
		->forEach(instanceSpec){
			instanceRef.instanceValue.instance:=instanceSpec;
		};
	};
	log('metadataRefs '+metadataRefs->size().repr());
	metadataRefs->forEach(instanceRef){
		var id:String=instanceRef.ref;
		xmlInstancePackage.packagedElement->select(i|(i.name=id) and i.oclIsKindOf(InstanceSpecification)).oclAsType(InstanceSpecification)
		->forEach(instanceSpec){
			// make a metadata dependency
			var dependency:Dependency=new Dependency();
			xmlInstancePackage.packagedElement+=dependency;
			dependency.name:='metadata';
			dependency.client+=instanceRef.instanceValue;
			dependency.supplier+=instanceSpec;
		};
	};
	return;
	}
helper OclAny::xmlInstanceDocumentElement(inout instance:InstanceSpecification,classifier:Classifier){
	// determine slot, either existing or create new
	// determine value: either InstanceValue or Literal
	// process attributes; if id then use for name; if metadata then handle later as a dependency
	// recurse for instances
	self.getElementAttributes()->forEach(attribute){
		var attributeName:String=attribute.getAttributeName();
		var attributeNamespace:String=attribute.getAttributeNamespace();
		if(attribute.isId())then{
			instance.name:=attribute.getAttributeValue();
		}else{
		
			if(
				(attributeNamespace='http://www.w3.org/2000/xmlns/')
				or(attributeNamespace=schemaForSchemaInstanceNamespace)
			)then{
				// ignore xmlns:*
			}else{
				if(attribute.isRef())then{
				}else{
					if(attribute.isMetadata())then{
					}else{
			//			attribute.xmlInstanceDocumentAttribute();
						var  slot:Slot=attribute.getElementSlot(instance,classifier);
						if(not(slot.oclIsUndefined()))then{
							var value:ValueSpecification=attribute.getAttributeValue(slot);
						}endif;
					}endif;
				}endif;
			}endif;
		}endif;
	};
	self.getElementElements()->forEach(element){
		var  slot:Slot=element.getElementSlot(instance,classifier);
		if(not(slot.oclIsUndefined()))then{
			var value:ValueSpecification=element.getElementValue(slot);
			if(value.oclIsKindOf(InstanceValue) and not(value.oclAsType(InstanceValue).instance.oclIsKindOf(EnumerationLiteral)))then{
				var instanceValue:InstanceValue=value.oclAsType(InstanceValue);
				var instanceSpecification:InstanceSpecification=instanceValue.instance;
					// look for metadata
					element.getElementAttributes()->forEach(attribute){
						if(attribute.isMetadata())then{
							var refId:String=attribute.getAttributeValue();
							var instanceRefPair:Tuple(instanceValue:UML::InstanceValue,ref:String)= 
								Tuple{instanceValue:UML::InstanceValue=instanceValue,ref:String=refId};
							metadataRefs+=instanceRefPair;
						}endif;
					};
				
				if(instanceSpecification.oclIsUndefined())then{
					// look for a ref
					element.getElementAttributes()->forEach(attribute){
						if(attribute.isRef())then{
							var refId:String=attribute.getAttributeValue();
							var instanceRefPair:Tuple(instanceValue:UML::InstanceValue,ref:String)= 
								Tuple{instanceValue:UML::InstanceValue=instanceValue,ref:String=refId};
							instanceRefs+=instanceRefPair;
						}endif;
					};
				}else{
				element.xmlInstanceDocumentElement(instanceSpecification,slot.definingFeature.type.oclAsType(Classifier));
				}endif;
			}endif;
		}endif;
	};
	return;
}

helper OclAny::isId():Boolean{
	return (self.getAttributeName()='id') and 	(self.getAttributeNamespace().isStructuresSchemaNamespace()) ;
}
helper OclAny::isRef():Boolean{
	return (self.getAttributeName()='ref') and 	(self.getAttributeNamespace().isStructuresSchemaNamespace()) ;
}
helper OclAny::isMetadata():Boolean{
	return (self.getAttributeName()='metadata') and 	(self.getAttributeNamespace().isStructuresSchemaNamespace()) ;
}
helper OclAny::getElementValue(inout slot:Slot):ValueSpecification{
	var value:ValueSpecification=null;
	// determine if instance or literal
	var feature:Property=slot.definingFeature.oclAsType(Property);
	var type:Classifier=feature.type.oclAsType(Classifier);
	if(type.oclIsKindOf(DataType))then{
		value:=self.getElementValueSpecification(slot);
	}else{
		value:=new InstanceValue();
		value.type:=type;
		// defer setting instance if this is a reference
//		if(feature.name.isReferenceName())then{
		if(feature.aggregation=AggregationKind::none)then{
			
		}else{
			var instance:InstanceSpecification=new InstanceSpecification();		
			value.oclAsType(InstanceValue).instance:=instance;
			var xmlInstancePackage:Package=slot.owningInstance.owningPackage;
//			instance.classifier+=feature.classifier;
			if(type.oclIsUndefined())then{
				log('ERROR: untyped Element '+feature.qualifiedName);
			}else{
				instance.classifier+=type;
				
			}endif;
			xmlInstancePackage.packagedElement+=instance;
		}endif;
	}endif;

	slot.value+=value;
	return value;
}
// not used
//query String::isReferenceName():Boolean=self.endsWith('Reference');

helper String::getEnumerationLiteral(enumeration:Enumeration):EnumerationLiteral{
	var enumerationLiteral:EnumerationLiteral=enumeration.ownedLiteral->select(l|l.name=self)->asSequence()->first();
	if(enumerationLiteral.oclIsUndefined())then{
		enumeration.general->select(e|e.oclIsKindOf(Enumeration)).oclAsType(Enumeration)->forEach(el){
			return self.getEnumerationLiteral(el);
		};
	}endif;
	return enumerationLiteral;
}
helper OclAny::getElementValueSpecification(inout slot:Slot):ValueSpecification{
	// this should always be a literal or enumerationliteral
	return self.getXSDElementValue().getValueSpecification(slot);
}
helper OclAny::getAttributeValue(inout slot:Slot):ValueSpecification{
	// this should always be a literal or enumerationliteral
	return self.getAttributeValue().getValueSpecification(slot);
}
helper String::getValueSpecification(inout slot:Slot):ValueSpecification{
	// this should always be a literal or enumerationliteral
	var value:ValueSpecification=null;
	var type:Classifier=slot.definingFeature.type.oclAsType(Classifier);
	
	var attributeValue:String=self;
	if(type.oclIsKindOf(Enumeration))then{
		value:=new InstanceValue();
		value.oclAsType(InstanceValue).instance:=attributeValue.getEnumerationLiteral(type.oclAsType(Enumeration));
	}else{
		if(type.isBoolean())then{
			value:=new LiteralBoolean();
			value.oclAsType(LiteralBoolean).value:=attributeValue.toLower()='true';
		}else{
			if(type.isInteger())then{
				value:=new LiteralInteger();
				value.oclAsType(LiteralInteger).value:=attributeValue.toInteger();
			}else{
				if(type.isReal())then{
					value:=new LiteralReal();
					value.oclAsType(LiteralReal).value:=attributeValue.toReal();
				}else{
					value:=new LiteralString();
					value.oclAsType(LiteralString).value:=attributeValue;
					
				}endif;
				
			}endif;
			
		}endif;
	}endif;
	value.type:=type;
	slot.value+=value;
	return value;
}

helper Classifier::isBoolean():Boolean{
	if('boolean'=(self.name.toLower()))then{return true;}endif;
	self.general->forEach(general){return general.isBoolean();};
	return false;
}
helper Classifier::isInteger():Boolean{
	if('integer'=(self.name.toLower()))then{return true;}endif;
	self.general->forEach(general){return general.isInteger();};
	return false;
}
helper Classifier::isReal():Boolean{
	var name:String =self.name.toLower();
	if(
		('boolean'=name)
		or ('decimal'=name)
		or ('double'=name)
		or ('real'=name)
		)then{return true;}endif;
	self.general->forEach(general){return general.isReal();};
	return false;
}
helper OclAny::getElementSlot(inout instance:InstanceSpecification,classifier:Classifier):Slot{
	var topLevelElement:Property=self.getNestedElement(classifier);
	if(topLevelElement.oclIsUndefined())then{
		log('ERROR: failed to resolve element '+self.getElementNamespace()+' : '+self.getElementName()+' in UML context '+classifier.qualifiedName);
		return null;
	}endif;
	// check if slot already defined
	instance.slot->select(s|s.definingFeature=topLevelElement)->forEach(existingSlot){
		return existingSlot;
	};
	var slot:Slot=new Slot();
	instance.slot+=slot;
	slot.definingFeature:=topLevelElement;
	return slot;
}
query UML::Property::getResolvedAttribute():UML::Property{
	var topLevelProperty:UML::Property=self.referencesTopLevelProperty();
	if((topLevelProperty=null) 
		or topLevelProperty.oclIsUndefined() 
		or (topLevelProperty.getNearestPackage()=null)
		or (topLevelProperty.getNearestPackage().oclIsUndefined())
		)then {return self;}endif;
	return topLevelProperty;
	}
helper OclAny::getNestedElement(classifier:Classifier):Property{
	// we should know the context in this case
	var tagName:String=self.getElementName();
	var targetNamespace:String=self.getElementNamespace();
	var targetInformationModel:Package=targetNamespace.getInformationModel();
	if(targetInformationModel.oclIsUndefined())then{
		log('Failed to resolve targetNamespace '+targetNamespace);
		return null;
	}endif;

//	var propertyResult:Property=classifier.getAllResolvedAttributes()
	var propertyResult:Property=classifier.getAllAttributes().getResolvedAttribute()
			->select(a|(a.name=tagName) and (targetInformationModel=a.getNearestPackage()))
//			->select(p|p.getNearestPackage()=targetInformationModel)
			->asSequence()->first();

	if(propertyResult.oclIsUndefined())then{

	
		// could be subsetted element
		// or could be property from subclass of classifier
		// need to find the property, probably in a PropertyHolder
		// need to allow for element definition in a foreign namespace
		// so we need to look at <<PropertyHolder>> Properties in <<InformationModel>> associated with the namespace
	propertyResult:=targetInformationModel.ownedType
			->select(t|t.isPropertyHolder()).oclAsType(Classifier).attribute
			->select(a|a.name=tagName)->asSequence()->first();

		
		// so we will need to examine all attributes of the classifier and track down their top level definitions, 
		// then get the properties subsetting those
		// propertyResult:=classifier.getAllSubstitutionAttributes()->select(a|a.name=tagName)->asSequence()->first();
		// if all that does not work, then start looking at subclassifiers
		if(propertyResult.oclIsUndefined())then{
			// search non-property holders
			propertyResult:=targetInformationModel.ownedType
//				->select(t|not(t.isPropertyHolder())).oclAsType(Classifier).attribute.getResolvedAttribute()
//				->select(t|t.oclIsKindOf(Classifier) and not(t.isPropertyHolder())).oclAsType(Classifier).attribute  // test
				->select(t|t.oclIsKindOf(Classifier) and not(t.isPropertyHolder())).oclAsType(Classifier).attribute.getResolvedAttribute()
				->select(a|(a.name=tagName) and (targetInformationModel=a.getNearestPackage()))
				
				->asSequence()->first();
			if(propertyResult.oclIsUndefined())then{
				// we searched all properties in information model at this point, and still could not find it
				log('Failed to locate property '+tagName+' in '+targetInformationModel.qualifiedName);
			}endif;
		}endif;
	}endif;
	return propertyResult;
}

/*
helper Classifier::getAllSubstitutionAttributes():Set(Property){
	
}
*/
helper OclAny::getTopLevelElement():Property{
	var targetNamespace:String=self.getElementNamespace();
	var targetName:String=self.getElementName();
	var targetSchema:Package=targetNamespace.getInformationModel();
	if(targetSchema.oclIsUndefined())then{
		log('ERROR: failed to find schema of top level element '+targetNamespace+' : '+targetName);
		return null;
	}endif;
	return targetSchema.ownedType->select(t|t.oclIsKindOf(Classifier)).oclAsType(Classifier).attribute
	->select(a|a.name=targetName)->asSequence()->first();
}
helper String::getInformationModel():Package{
	return allSchemaTargetNamespaces->select(t|t.targetNamespace=self).schema->asSequence()->first();
}
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
helper CMOF::EObject::getDocumentAtRelativeURI(relativeURI:String):OclAny{
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('getDocumentAtRelativeURI');
	annotation._references+=self;
	"relativeURI".setAnnotationDetail(annotation,relativeURI);
	blackboxHook.eAnnotations+=annotation;
	return annotation.eAnnotations->asSequence()->first();
	}

helper UML::Package::getMpdRelativePathForPackage(in topPackage:UML::Package):String{
	if(self=topPackage)then{return '.';}endif;
	return self.nestingPackage.getMpdRelativePathForPackage(topPackage)+'/'+self.name;
}

helper CMOF::EObject::getRootFileName():String{
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('getRootFileName');
	annotation._references+=self;
	blackboxHook.eAnnotations+=annotation;
	return annotation.getDetail('rootFileName');
	}

helper 		gatherCatalogedSchemas(mpdRootPackage:UML::Package){
		mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isStereotypeApplied(NIEMSchemaStereotype))
			->forEach(schemaPackage){
				var schemaTuple:Tuple(schema:UML::Package,
						targetNamespace:String)=
						Tuple{schema:UML::Package=schemaPackage,
						targetNamespace:String=schemaPackage.getStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element).getSchemaTargetNamespace()};
				log('Schema proxy for '+schemaTuple.targetNamespace+', '+schemaTuple.schema.qualifiedName);		
				schemaTargetNamespaces+=schemaTuple;		
			};
		log('schemaTuple proxies '+schemaTargetNamespaces->size().repr());	
		mapInit();
		catalog.map CatalogType();
		return;
}
helper mapInit(){
	var annotation:CMOF::EAnnotation=new CMOF::EAnnotation('mapInit');
	blackboxHook.eAnnotations+=annotation;
	return;
 	}
mapping 	CAT::CatalogType::CatalogType():UML::Model@pimUml
{
	mpdRootPackage.packagedElement+=result;
	mpdRootPackage:=result;
	// there is no longer an mpdName: extract from directory name
//	mpdRootPackage.name:=self.mpdName;
	mpdRootPackage.name:=self.mPD.mpdName;
//	mpdRootPackage.name:=self.getMpdName();
	result.applyProfile(logicalProfile);
	result.applyProfile(provisioningProfile);
	result.applyProfile(structureProfile);
	result.applyProfile(niemXsdProfile);
	self.map MpdCatalog_ProvisioningComponent(result);
}
/*
query CAT::Catalog::getMpdName():String{
	var baseName:String=self.oclAsType(CMOF::EObject).getDirectoryName();
	var index:Integer=baseName.lastIndexOf("-");
	return baseName.substring(1,index-1);
}
query CAT::Catalog::getMpdVersionID():String{
	var baseName:String=self.oclAsType(CMOF::EObject).getDirectoryName();
	var index:Integer=baseName.lastIndexOf("-");
	var tail:String=baseName.substring(index+1,baseName.length());
	var versionEnd=tail.indexOf(".");
	return tail.substring(1,versionEnd-1);
}
*/
query CMOF::EObject::getDirectoryName():String{
	var baseName:String=self.getModelDirectoryName();
	return baseName;
}
//mapping 	CAT::CatalogType::MpdCatalog_ProvisioningComponent(	inout newPackage:UML::Package):UML::Component@pimUml{
mapping 	CAT::CatalogType::MpdCatalog_ProvisioningComponent(	inout newPackage:UML::Package):UML::InstanceSpecification@pimUml{
	
	newPackage.packagedElement+=result;
	classifier+=prompdStereotype;
	mpdComponent:=result;
	var mpd:CAT::MPDType=self.mPD;
	// there is no longer an mpdName: extract from directory name
	var baseModelName:String= mpd.mpdName;
	name:=baseModelName;
	// process all content
	// create the items, establish containment, set stereotypes and apply tags discretely
//	var pimmpd:Stdlib::Element=result.applyStereotype(prompdStereotype);
	var pimmpd:UML::InstanceSpecification=result;
	// there is no longer an mpdVersionID: extract from directory name
//	pimmpd.setMpdVersionID(self.mpdVersionID);
	pimmpd.setMpdVersionID(mpd.mpdVersionID);
	mpd.mpdClassURIList->forEach(classCode){
		switch{
			case(classCode='http://reference.niem.gov/niem/specification/model-package-description/3.0/#IEPD')pimmpd.setMpdClassCode('iepd');
			else{
				log('mpdClassURI not recognized: '+classCode.repr());
			}
		};	
	};
	pimmpd.setMpdBaseURI(mpd.mpdURI.expandURI().mpdURItoBaseMpdUri(mpd.mpdVersionID));
//	pimmpd.setMpdDescriptionText(mpd.descriptionText.value);
	pimmpd.setDescriptionText(mpd.descriptionText.value);
	mpd.IEPConformanceTarget(pimmpd);	
   	pimmpd.ArtifactOrArtifactSet(mpd);
//	mpd.mPDInformation.MPDInformation(pimmpd,result);
	mpd.mPDInformation.MPDInformation(result);
}
//helper Stdlib::Element::ArtifactOrArtifactSet(mpd:Stdlib::Element){
helper UML::InstanceSpecification::ArtifactOrArtifactSet(mpd:Stdlib::Element){
	// fileType refs are usages; fileSets are instances;
	// this helper creates both
//	var umlArtifactOrArtifactSetList:Stdlib::Element=self.getArtifactOrArtifactSetList();
	var umlArtifactOrArtifactSetList:UML::Slot=self.getArtifactOrArtifactSetList();
	//	mpd.artifactOrArtifactSet.oclAsType(Stdlib::Element)->forEach(artifact){
//		var umlArtifact:Stdlib::Element=umlArtifactOrArtifactSetList.createArtifactInstance(artifact);
//		var umlArtifact:Stdlib::Element=umlArtifactOrArtifactSetList.createArtifactOrArtifactSetInstance(artifact);
//    	artifact.ArtifactOrArtifactSet(mpd,umlArtifact);

	umlArtifactOrArtifactSetList.createFileInstance(mpd,'file','FileType');
	umlArtifactOrArtifactSetList.createFileInstance(mpd,'xMLCatalog','XMLCatalog');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'mPDChangeLog','MPDChangeLog');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'readMe','ReadMe');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'iEPSampleXMLDocument','IEPSampleXMLDocument');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'businessRulesArtifact','BusinessRulesArtifact');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'xMLSchemaDocument','XMLSchemaDocument');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'externalSchemaDocument','ExternalSchemaDocument');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'extensionSchemaDocument','ExtensionSchemaDocument');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'subsetSchemaDocument','SubsetSchemaDocument');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'referenceSchemaDocument','ReferenceSchemaDocument');
    // wrong type?
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'eXIXMLSchema','EXIXMLSchemaType');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'wantlist','Wantlist');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'conformanceAssertion','ConformanceAssertion');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'conformanceReport','ConformanceReport');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'schematronSchema','SchematronSchema');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'relaxNGSchema','RelaxNGSchema');
		umlArtifactOrArtifactSetList.createFileInstance(mpd,'schematronSchema','SchematronSchema');
		
			umlArtifactOrArtifactSetList.createFileInstance(mpd,'documentation','Documentation');
			
			umlArtifactOrArtifactSetList.createFileSetInstance(mpd,'fileSet','FileSetType');
			umlArtifactOrArtifactSetList.createFileSetInstance(mpd,'schemaDocumentSet','SchemaDocumentSet');
			umlArtifactOrArtifactSetList.createFileSetInstance(mpd,'constraintSchemaDocumentSet','ConstraintSchemaDocumentSet');
			
			
	
    return;
}
//helper UML::InstanceSpecification::RequiredFile(fileType:CAT::FileType){
helper UML::Usage::RequiredFile(fileType:CAT::FileType){
	if(fileType.requiredFile->notEmpty())then{
//		var umlRequiredFileList:UML::Slot=self.getRequiredFileList();
		fileType.requiredFile->forEach(requiredFile){
//			var umlRequiredFile:UML::InstanceSpecification=umlRequiredFileList.createInstance();
//			log('WARNING: requiredFile not yet supported');
			//umlRequiredFile.populateFileInstance(requiredFile);
			// create Usage from the FileType Usage supplier to the referenced requiredFile,
			//  stereotyped as <<RequiredFile>>
			var requiredUsage:UML::Usage=new UML::Usage();
			self.getNearestPackage().packagedElement+=requiredUsage;
			requiredUsage.client+=self.supplier;
//	result.supplier+=supplierIn;
			var requiredInstance:UML::InstanceSpecification=requiredUsage.applyStereotype(provisioningProfile.getOwnedStereotype('RequiredFile')).oclAsType(UML::InstanceSpecification);
			requiredInstance.populateFileInstance(requiredFile,requiredUsage);
	    };
    }endif;
    return;
}

helper  UML::InstanceSpecification::populateFileInstance(fileType:CAT::FileType,inout usage:UML::Usage){
	var fileInstance:UML::InstanceSpecification=self;
	fileInstance.setDescriptionText(fileType.descriptionText.value);
	//fileInstance.setPathURI(fileType.pathURI);// use implicit form so that we can re-align packages to niem3 structure
	fileInstance.setMimeMediaTypeText(fileType.mimeMediaTypeText);
	fileInstance.setExternalURI(fileType.externalURI);
	fileInstance.name:=fileType.pathURI;
//	umlArtifact.setRequiredFile(fileType.requiredFile);
//	fileInstance.RequiredFile(fileType);
	usage.RequiredFile(fileType);

	// if appropriate, add file type
	if(self.classifier.name->includes('ExtensionSchemaDocument'))then{
            self.addFileType(fileType,usage);
	}endif;	
	if(self.classifier.name->includes('ExternalSchemaDocument'))then{
            self.addFileType(fileType,usage);
	}endif;	
	if(self.classifier.name->includes('ReferenceSchemaDocument'))then{
            self.addFileType(fileType,usage);
	}endif;	
	if(self.classifier.name->includes('SubsetSchemaDocument'))then{
            self.addFileType(fileType,usage);
	}endif;	
	if(self.classifier.name->includes('XMLSchemaDocument'))then{
            self.addFileType(fileType,usage);
	}endif;	
	/*
	 mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','xMLSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','externalSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','referenceSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#reference-schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','extensionSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#extension-schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','subsetSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#subset-schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
	*/
	
	return;
}

helper 	UML::InstanceSpecification::addFileType(inout fileType:CAT::FileType,inout usage:UML::Usage):UML::Usage
{
	var umlPackagePath:String=fileType.pathURI.toRelativeMdpLocation();
	var ownerPackage:UML::Package=umlPackagePath.getOwnerPackage(mpdRootPackage);
	var fileTypePackage:UML::Package=null;
	if(fileType.pathURI.endsWith('.xsd'))then{
		var schema:XSD::XSDSchema=fileType.oclAsType(CMOF::EObject).getSchemaAtRelativeURI(fileType.pathURI).oclAsType(XSD::XSDSchema);
		if(not(schema.oclIsUndefined()))then{
			// and map it as schema
			fileTypePackage:=schema.mapAbstractXSDSchema();
			// no mapping if proxy, structures, etc.
			if(fileTypePackage.oclIsUndefined())then{return null;}endif;
			ownerPackage.packagedElement+=fileTypePackage;
			var stereotypeInstance:Stdlib::Element=fileTypePackage.getStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
			if(not(stereotypeInstance.oclIsUndefined()))then{
//				schema.setModelInformationDefaultPurpose(purposeURI.expandURI(),stereotypeInstance);
				var defaultPurpose:String='extension';
				if(schema.targetNamespace.startsWith(baseNiemNamespace)
					or schema.targetNamespace.startsWith(baseNiemNamespaceNiem2) 
					or (schema.targetNamespace='urn:us:gov:ic:ism:v2') )then{
						defaultPurpose:='subset';
				}endif;
				stereotypeInstance.setInformationModelDefaultPurpose(defaultPurpose);
				
			}endif;
		}endif;
	}endif;	
	if((fileTypePackage=null))then{
		// for artifacts not recognized (not schemas) we map to a UML Package
//		fileTypePackage:=fileType.map FileTypePackage(ownerPackage,pimComponent);
		fileTypePackage:=fileType.map FileTypePackage(ownerPackage);
	}endif;
//	return fileType.map FileType(fileTypePackage,pimComponent,purposeURI,natureURI);
//	return self.map FileType(fileTypePackage);
	return self.mapFileType(fileTypePackage,usage);
}

// map the Catalog Uri entry to a <<ModelPackageDescriptionFile>> Usage
//mapping 	CAT::FileType::FileType(inout pimPackage:UML::NamedElement,inout pimComponent:UML::Component,inout pimFileType:Stdlib::Element)
//mapping 	UML::InstanceSpecification::FileType(inout pimPackage:UML::NamedElement)
helper 	UML::InstanceSpecification::mapFileType(inout pimPackage:UML::NamedElement,inout usage:UML::Usage)
	:UML::Usage@pimUml
//	when{not(purposeURI.expandURI().isPurposeCatalog())}
{
	usage.supplier+=pimPackage;
//	client+=pimComponent;
//	pimComponent.packagedElement+=result;
	usage.client+=self;
	if(self.owner.oclIsKindOf(UML::Component))then{
		self.owner.oclAsType(UML::Component).packagedElement+=usage;
	}else{
		self.getNearestPackage().packagedElement+=usage;
	}endif;
	/*
	pimComponent.packagedElement+=result;
	var pimNdrSchemaInstance:Stdlib::Element=result.applyStereotype(NIEMModelPackageDescriptionFileStereotype);
	// set version, conformant, purpose
	pimNdrSchemaInstance.setDescriptionText(self.descriptionText.value);
	pimNdrSchemaInstance.setFileTypeExternalURI(self.externalURI.expandURI());
	pimNdrSchemaInstance.setFileTypePurposeCode(purposeURI.expandURI());
	pimFileType.setPathURI('');
	*/
	return usage;
}


// represent non-schema artifacts as a package
//mapping 	CAT::FileType::FileTypePackage(inout ownerPackage:UML::Package,inout pimComponent:UML::Component):UML::Package@pimUml
mapping 	CAT::FileType::FileTypePackage(inout ownerPackage:UML::Package):UML::Package@pimUml
{
//	var umlPackagePath:String=self.relativePathName.toRelativeMdpLocation();
	var umlPackagePath:String=self.pathURI.toRelativeMdpLocation();
	
//	var umlPackagePath:String=self.uri.toRelativeMdpLocation();
	ownerPackage.packagedElement+=result;
	result.name:=umlPackagePath.toBaseName();
}

helper  UML::InstanceSpecification::populateFileSetInstance(fileType:CAT::FileSetType){
	var fileSetInstance:UML::InstanceSpecification=self;
	fileSetInstance.setDescriptionText(fileType.descriptionText.value);
	fileSetInstance.setPathURI(fileType.pathURI);
	fileSetInstance.setExternalURI(fileType.externalURI);
	fileSetInstance.name:=fileType.pathURI;
	// and realizations?
	//umlArtifact.setArtifactOrArtifactSet(fileType.artifactOrArtifactSet);
//   	fileSetInstance.oclAsType(Stdlib::Element).ArtifactOrArtifactSet(fileType);
   	fileSetInstance.ArtifactOrArtifactSet(fileType);
	return;
}

helper  UML::Slot::createFileInstance(mpdCatalogType:Stdlib::Element,umlFeatureName:String,umlClassName:String){
//helper  UML::Slot::createFileInstance(mpdCatalogType:Stdlib::Element,umlFeatureName:String,umlClassName:String,supplier:UML::NamedElement){
	mpdCatalogType.getFeatureMapValue('artifactOrArtifactSetGroup',umlFeatureName).oclAsType(CAT::FileType)->forEach(fileType){
//		self.createArtifactInstance(umlClassName).populateFileInstance(fileType);
		var client:UML::NamedElement=self.owningInstance;
//		fileType.map FileTypeUsage(umlClassName,client,supplier);
		fileType.map FileTypeUsage(umlClassName,client);
//		populateFileInstance(fileType);
    };
	return;
}

//mapping 	CAT::FileType::FileTypeUsage(stereotypeName:String,clientIn:UML::NamedElement,supplierIn:UML::NamedElement):UML::Usage@pimUml
mapping 	CAT::FileType::FileTypeUsage(stereotypeName:String,clientIn:UML::NamedElement):UML::Usage@pimUml
{
	clientIn.getNearestPackage().packagedElement+=result;
	result.client+=clientIn;
//	result.supplier+=supplierIn;
	var appliedStereotype:Stdlib::Element=result.applyStereotype(provisioningProfile.getOwnedStereotype(stereotypeName));
	appliedStereotype.oclAsType(UML::InstanceSpecification).populateFileInstance(self,result);
//UML::InstanceSpecification::populateFileInstance(fileType:CAT::FileType){	
}

helper  UML::Slot::createFileSetInstance(mpdCatalogType:Stdlib::Element,umlFeatureName:String,umlClassName:String){
	mpdCatalogType.getFeatureMapValue('artifactOrArtifactSetGroup',umlFeatureName).oclAsType(CAT::FileSetType)->forEach(fileType){
		self.createArtifactInstance(umlClassName).populateFileSetInstance(fileType);
    };
	return;
}


/*
abstract helper  Stdlib::Element::createArtifactOrArtifactSetInstance(concreteInstance:Stdlib::Element){
	var umlArtifact:Stdlib::Element=self.createArtifactInstance(concreteInstance);
	return;
}
helper  Stdlib::Element::createArtifactOrArtifactSetInstance(concreteInstance:Stdlib::Element){
	var umlArtifact:Stdlib::Element=self.createArtifactInstance(concreteInstance);
	return;
}

helper Stdlib::Element::ArtifactOrArtifactSet(mpd:CAT::MPDType){
	var umlArtifactOrArtifactSetList:Stdlib::Element=self.getArtifactOrArtifactSetList();
	mpd.artifactOrArtifactSet.oclAsType(Stdlib::Element)->forEach(artifact){
//		var umlArtifact:Stdlib::Element=umlArtifactOrArtifactSetList.createArtifactInstance(artifact);
		var umlArtifact:Stdlib::Element=umlArtifactOrArtifactSetList.createArtifactOrArtifactSetInstance(artifact);
//    	artifact.ArtifactOrArtifactSet(mpd,umlArtifact);
	/ *
	 mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','xMLSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','externalSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','referenceSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#reference-schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','extensionSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#extension-schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    mpd.oclAsType(CMOF::EObject).getFeatureMapValue('artifactOrArtifactSetGroup','subsetSchemaDocument')->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
            file.addFileType(mpdComponent,'http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/purpose#subset-schema','http://reference.niem.gov/niem/resource/mpd/lexicon/1.0/nature#xsd');
    };
    
//	 self.artifact->select(f|f.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)->forEach(file){
//            file.addFileType(mpdComponent);
//    };
//    self.artifact->select(f|f.oclIsKindOf(CAT::FileSetType)).oclAsType(CAT::FileSetType).map FileSetType();
    mpd.artifactOrArtifactSet->select(f|f.oclIsKindOf(CAT::FileSetType)).oclAsType(CAT::FileSetType).map FileSetType();
    * /
    };
    return;
}
*/
helper CAT::MPDType::IEPConformanceTarget(pimmpd:UML::InstanceSpecification){
	if(self.iEPConformanceTarget->notEmpty())then{
		var umlIEPConformanceTargetList:UML::Slot=pimmpd.getIEPConformanceTargetList();
		self.iEPConformanceTarget->forEach(iepConformanceTarget){
			var umlIEPConformanceTarget:UML::InstanceSpecification=umlIEPConformanceTargetList.createInstance();
	//		umlIEPConformanceTarget.setConformanceTargetDescriptionText(iepConformanceTarget.descriptionText.repr());
			umlIEPConformanceTarget.setDescriptionText(iepConformanceTarget.descriptionText.value);
			iepConformanceTarget.ValidityConstraintWithContext(umlIEPConformanceTarget);
	//		iepConformanceTarget.ArtifactOrArtifactSet(umlIEPConformanceTarget);
//			umlIEPConformanceTarget.oclAsType(Stdlib::Element).ArtifactOrArtifactSet(iepConformanceTarget);
			umlIEPConformanceTarget.ArtifactOrArtifactSet(iepConformanceTarget);
	    };
	}endif;
}
//mapping CAT::RelationshipType::ModelPackageDescriptionRelationship(inout mpd:UML::Component,relatedEntity:UML::NamedElement):UML::Dependency
mapping CAT::RelationshipType::ModelPackageDescriptionRelationship(inout mpd:UML::InstanceSpecification,relatedEntity:UML::NamedElement):UML::Dependency
{
		mpd.getNearestPackage().packagedElement+=result;
		var appliedStereotype:Stdlib::Element=result.applyStereotype(NIEMModelPackageDescriptionRelationshipStereotype);
		appliedStereotype.setDescriptionText(self.descriptionText.value);
		var code:String=self.relationshipCode.repr();
		appliedStereotype.setRelationshipCode(code);
		client+=mpd;
		supplier+=relatedEntity;				
}
	
//helper CAT::MPDInformationType::MPDInformation(pimmpd:Stdlib::Element,mpd:UML::Component){
helper CAT::MPDInformationType::MPDInformation(pimmpd:UML::InstanceSpecification){
		var metadata:CAT::MPDInformationType=self;
		pimmpd.setMpdCreationDate(metadata.creationDate.value.repr());
				log('MPDInformation creationDate: '+metadata.creationDate.value.repr());
		
		pimmpd.setMpdLastRevisionDate(metadata.lastRevisionDate.value.repr());
		// Relationship
		metadata.relationship->forEach(rel){
//			var supplier:UML::NamedElement=mpd;// TODO: make this an MPD or some other concrete external 
//			rel.map ModelPackageDescriptionRelationship(mpd,supplier);
			var supplier:UML::NamedElement=pimmpd;// TODO: make this an MPD or some other concrete external 
			rel.map ModelPackageDescriptionRelationship(pimmpd,supplier);
		};	
		metadata.statusText.value->forEach(text){pimmpd.setMpdStatusText(text);};
 		if(metadata.keywordText.value->notEmpty())then{
			pimmpd.setMpdKeywordText(metadata.keywordText.value);
			}endif;
 		if(metadata.keywordText.value->notEmpty())then{
			pimmpd.setMpdDomainText(metadata.domainText.value);
			}endif;
		if(metadata.keywordText.value->notEmpty())then{
			pimmpd.setMpdPurposeText(metadata.purposeText.value);
			}endif;
		if(metadata.keywordText.value->notEmpty())then{
			pimmpd.setMpdExchangePatternText(metadata.exchangePatternText.value);
			}endif;
		if(metadata.keywordText.value->notEmpty())then{
			pimmpd.setMpdExchangePartnerName(metadata.exchangePartnerName.value);
			}endif;
		if(self.authoritativeSource.entityRepresentation->notEmpty())then{
			var authoritativeSourceList:UML::Slot=pimmpd.getAuthoritativeSourceList();
			self.authoritativeSource.AuthoritativeSource(authoritativeSourceList);
		}endif;
		
}
		
helper CAT::IEPConformanceTargetType::ValidityConstraintWithContext(umlIEPConformanceTarget:UML::InstanceSpecification){
//            <xs:element ref="c:ValidityConstraintWithContext" minOccurs="0" maxOccurs="unbounded"/>
//    <xs:element name="ValidityConstraintWithContext" abstract="true">
//    <xs:element name="ValidityConstraint" abstract="true" substitutionGroup="c:ValidityConstraintWithContext">
//    <xs:element name="ValidityContext" type="c:ValidityContextType" substitutionGroup="c:ValidityConstraintWithContext">
//    <xs:element name="HasDocumentElement" type="c:QualifiedNamesType" substitutionGroup="c:ValidityConstraintWithContext">

//<xs:element name="ValidToXPath" type="c:XPathType" substitutionGroup="c:ValidityConstraint">
//<xs:element name="XMLSchemaValid" type="c:XMLSchemaType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="SchematronValid" type="c:SchematronValidationType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="RelaxNGValid" type="c:RelaxNGValidationType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="ConformsToConformanceTarget" type="c:ConformanceTargetType" substitutionGroup="c:ValidityConstraint">
//    <xs:element name="ConformsToRule" type="c:TextRuleType" substitutionGroup="c:ValidityConstraint">
        
		var umlValidityConstraintWithContextList:UML::Slot=umlIEPConformanceTarget.getValidityConstraintWithContextList();
		self.validityConstraintWithContext->forEach(validityConstraint){
//			var umlValidityConstraintWithContext:UML::InstanceSpecification=umlValidityConstraintWithContextList.createInstance();
			var umlValidityConstraintWithContext:UML::InstanceValue=createInstanceValue(umlValidityConstraintWithContextList);
			
//			umlValidityConstraintWithContext.setValidityConstraintWithContext(iepConformanceTarget.validityConstraintWithContext);
//			umlValidityConstraintWithContext.instance:=validityConstraint.map AbstractValidityConstraintWithContext();
	
			switch{
				case(validityConstraint.oclIsKindOf(CAT::ValidityContextType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::ValidityContextType).map ValidityContextType();
				case(validityConstraint.oclIsKindOf(CAT::QualifiedNamesType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::QualifiedNamesType).map QualifiedNamesType();
				case(validityConstraint.oclIsKindOf(CAT::XPathType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::XPathType).map XPathType();
				case(validityConstraint.oclIsKindOf(CAT::XMLSchemaType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::XMLSchemaType).map XMLSchemaType();
				case(validityConstraint.oclIsKindOf(CAT::SchematronValidationType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::SchematronValidationType).map SchematronValidationType();
				case(validityConstraint.oclIsKindOf(CAT::RelaxNGValidationType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::RelaxNGValidationType).map RelaxNGValidationType();
				case(validityConstraint.oclIsKindOf(CAT::ConformanceTargetType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::ConformanceTargetType).map ConformanceTargetType();
				case(validityConstraint.oclIsKindOf(CAT::TextRuleType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::TextRuleType).map TextRuleType();
	
				else{
					log('ValidityConstraintWithContext not recognized: '+validityConstraint.repr());
				}
			};
		
		};
		
}
mapping CAT::ValidityContextType::ValidityContextType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:ValidityConstraint" maxOccurs="unbounded"/>
//          </xs:sequence>
//          <xs:attribute ref="c:xPathText" use="required"/>
	classifier+=ValidityContextTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	result.setXPathText(self.xPathText);
	var umlValidityConstraintList:UML::Slot=result.getValidityConstraintList();
	self.validityConstraint->forEach(validityConstraint){
			var umlValidityConstraintWithContext:UML::InstanceValue=createInstanceValue(umlValidityConstraintList);
			switch{
				case(validityConstraint.oclIsKindOf(CAT::XPathType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::XPathType).map XPathType();
				case(validityConstraint.oclIsKindOf(CAT::XMLSchemaType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::XMLSchemaType).map XMLSchemaType();
				case(validityConstraint.oclIsKindOf(CAT::SchematronValidationType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::SchematronValidationType).map SchematronValidationType();
				case(validityConstraint.oclIsKindOf(CAT::RelaxNGValidationType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::RelaxNGValidationType).map RelaxNGValidationType();
				case(validityConstraint.oclIsKindOf(CAT::ConformanceTargetType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::ConformanceTargetType).map ConformanceTargetType();
				case(validityConstraint.oclIsKindOf(CAT::TextRuleType))
					umlValidityConstraintWithContext.instance:=validityConstraint.oclAsType(CAT::TextRuleType).map TextRuleType();
	
				else{
					log('ValidityConstraintWithContext not recognized: '+validityConstraint.repr());
				}
			};
		
		
	};

} 
mapping CAT::QualifiedNamesType::QualifiedNamesType():UML::InstanceSpecification{
//	            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//          <xs:attribute ref="c:qualifiedNameList" use="required"/>
//    <xs:attribute name="qualifiedNameList" type="c:QualifiedNameListSimpleType">
//    <xs:simpleType name="QualifiedNameListSimpleType">
//      <xs:list itemType="xs:QName"/>
//    </xs:simpleType>
	classifier+=QualifiedNamesTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	result.setQualifiedNameList(self.qualifiedNameList.repr());	
} 
mapping CAT::XPathType::XPathType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//          <xs:attribute ref="c:xPathText" use="required"/>
	classifier+=XPathTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	result.setXPathText(self.xPathText);
} 
mapping CAT::XMLSchemaType::XMLSchemaType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText"  minOccurs="0"/>
//            <xs:element ref="c:XMLCatalog"          minOccurs="0" maxOccurs="unbounded"/>
//            <xs:element ref="c:XMLSchemaDocument" minOccurs="0" maxOccurs="unbounded"/>
	classifier+=XMLSchemaTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	
	/* TODO; not sure what this actually means
	self.xMLCatalog.map XMLCatalog(result);// usage
	self.xMLSchemaDocument.map XMLSchemaDocument(result);// usage
	*/
	/* Usage
	var xMLCatalogList:UML::Slot=result.getXMLCatalogList();
	self.xMLCatalog->forEach(xmlCatalog){
		xMLCatalogList.instance:=xmlCatalog.oclAsType(CAT::XMLCatalogType).map XMLCatalogType();
	};
	var xMLSchemaDocumentList:UML::Slot=result.getXMLSchemaDocumentList();
	self.xMLSchemaDocument->forEach(xmlSchemaDocument){
		xmlSchemaDocument.instance:=xmlSchemaDocument.oclAsType(CAT::XMLSchemaDocumentType).map XMLSchemaDocumentType();
	};
*/
} 
mapping CAT::SchematronValidationType::SchematronValidationType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:SchematronSchema"/>
	classifier+=SchematronValidationTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	// TODO: not yet supporting Schematron
	//self.schematronSchema.map SchematronSchema(result);// Usage
	//result.setSchematronSchema(self.schematronSchema.value);// Usage
} 
mapping CAT::RelaxNGValidationType::RelaxNGValidationType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:RelaxNGSchema"/>
	classifier+=RelaxNGValidationTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	// TODO: not yet supporting RelaxNG
	//self.relaxNGSchema.map RelaxNGSchema(result);
	//result.setRelaxNGSchema(self.relaxNGSchema.value);// Usage
	

} 
mapping CAT::ConformanceTargetType::ConformanceTargetType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//          <xs:attribute ref="c:conformanceTargetURI" use="required"/>
	classifier+=ConformanceTargetTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	result.setConformanceTargetURI(self.conformanceTargetURI);
} 
mapping CAT::TextRuleType::TextRuleType():UML::InstanceSpecification{
//            <xs:element ref="nc:DescriptionText" minOccurs="0"/>
//            <xs:element ref="c:RuleText"/>
	classifier+=TextRuleTypeArtifact;
	result.setDescriptionText(self.descriptionText.value);
	result.setRuleText(self.ruleText.value);
	

} 
/*
helper CAT::IEPConformanceTargetType::ArtifactOrArtifactSet(umlIEPConformanceTarget:Stdlib::Element){
		var umlArtifactOrArtifactSetList:Stdlib::Element=umlIEPConformanceTarget.getArtifactOrArtifactSetList();
		self.artifactOrArtifactSet->forEach(artifact){
			var umlArtifactOrArtifactSet:Stdlib::Element=umlArtifactOrArtifactSetList.createInstance();
//			umlValidityConstraintWithContext.setValidityConstraintWithContext(iepConformanceTarget.validityConstraintWithContext);
		};
}
*/
helper NC::EntityType::AuthoritativeSource(authoritativeSourceList:UML::Slot){
		self.entityRepresentation->select(e|e.oclIsKindOf(NC::OrganizationType)).oclAsType(NC::OrganizationType)
			->forEach(organization){
				var organizationInstance:UML::InstanceSpecification=authoritativeSourceList.createArtifactInstance('OrganizationType');
	//			pimmpd.setMpdASName(organization.aSName);
	//			pimmpd.setMpdASAddressText(organization.aSAddressText);
	//			pimmpd.setMpdASWebSiteURL(organization.aSWebSiteURL);
				organizationInstance.setNames(organization.organizationName.value);
				var organizationPrimaryContactInformationList:UML::Slot=organizationInstance.getOrganizationPrimaryContactInformationList();	
				organization.organizationPrimaryContactInformation.ContactInformationType(organizationPrimaryContactInformationList);
		};
}
helper NC::ContactInformationType::ContactInformationType(organizationPrimaryContactInformationList:UML::Slot){
		var contactInformationInstance:UML::InstanceSpecification=organizationPrimaryContactInformationList.createArtifactInstance('ContactInformationType');
		contactInformationInstance.setContactEmailIDs(self.contactEmailID());
		contactInformationInstance.setContactMailingAddresses(self.contactMailingAddress());
		contactInformationInstance.setContactTelephoneNumbers(self.contactTelephoneNumber());
		contactInformationInstance.setContactWebsiteURIs(self.contactWebsiteURI());
		var contactEntityList:UML::Slot=contactInformationInstance.getContactEntityList();
		self.contactEntity.AuthoritativeSource(contactEntityList);
		
		var contactResponderList:UML::Slot=contactInformationInstance.getContactResponderList();
		self.contactResponder.PersonType(contactResponderList);
		return;
}

		
		// TODO: following, get many substitution 

helper NC::PersonType::PersonType(contactResponderList:Stdlib::Element){
		//var personInstance:Stdlib::Element=contactResponderList.createArtifactInstance('PersonType');
		//personInstance.setNames(self.personName.personFullName.value);
		return ;
}

/*	
query String::isPurposeCatalog():Boolean=self.substringAfter('#')='catalog';
	
//helper 	CAT::FileType::addFileType(inout pimComponent:UML::Component):UML::Usage
helper 	CAT::FileType::addFileType(inout pimComponent:UML::Component,purposeURI:String,natureURI:String):UML::Usage
{
//	var umlPackagePath:String=self.relativePathName.toRelativeMdpLocation();
	var umlPackagePath:String=self.pathURI.toRelativeMdpLocation();
	//var umlPackagePath:String=self.uri.toRelativeMdpLocation();
	var ownerPackage:UML::Package=umlPackagePath.getOwnerPackage(mpdRootPackage);
	var fileTypePackage:UML::Package=null;
//	if(self.relativePathName.endsWith('.xsd'))then{
	if(self.pathURI.endsWith('.xsd'))then{
//	if(self.uri.endsWith('.xsd'))then{
//		var schema:XSD::XSDSchema=self.oclAsType(CMOF::EObject).getSchemaAtRelativeURI(self.relativePathName).oclAsType(XSD::XSDSchema);
		var schema:XSD::XSDSchema=self.oclAsType(CMOF::EObject).getSchemaAtRelativeURI(self.pathURI).oclAsType(XSD::XSDSchema);
//		var schema:XSD::XSDSchema=self.oclAsType(CMOF::EObject).getSchemaAtRelativeURI(self.uri).oclAsType(XSD::XSDSchema);
		if(not(schema.oclIsUndefined()))then{
			// and map it as schema
			fileTypePackage:=schema.mapAbstractXSDSchema();
			// no mapping if proxy, structures, etc.
			if(fileTypePackage.oclIsUndefined())then{return null;}endif;
			ownerPackage.packagedElement+=fileTypePackage;
			var stereotypeInstance:Stdlib::Element=fileTypePackage.getStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
			if(not(stereotypeInstance.oclIsUndefined()))then{
				
//				schema.setModelInformationDefaultPurpose(self.purposeURI.expandURI(),stereotypeInstance);
				schema.setModelInformationDefaultPurpose(purposeURI.expandURI(),stereotypeInstance);
			}endif;
		}endif;
	}endif;	
	if((fileTypePackage=null))then{
		// for artifacts not recognized (not schemas) we map to a UML Package
		fileTypePackage:=self.map FileTypePackage(ownerPackage,pimComponent);
	}endif;
//	return self.map FileType(fileTypePackage,pimComponent);
	return self.map FileType(fileTypePackage,pimComponent,purposeURI,natureURI);
}

mapping 	CAT::FileSetType::FileSetType():UML::Component@pimUml
{
	// perhaps a dependency with multiple sources as the referenced files; (ref vs containment? - flag in FileType)	
	name:=self.id;
	mpdComponent.packagedElement+=result;
	self.artifactOrArtifactSet->select(a|a.oclIsKindOf(CAT::FileType)).oclAsType(CAT::FileType)
	//self.file
	->forEach(file){
//		var referencedFile:UML::NamedElement=file.addFileType(result);
		var referencedFile:UML::NamedElement=file.addFileType(result,purposeURI,natureURI);
	};
	// referenced files
//	self.files
	self.artifactOrArtifactSet
		->select(f|not(f.oclIsUndefined()))->forEach(fileRef){
			var file:CAT::FileType=catalog.allSubobjectsOfKind(CAT::FileType).oclAsType(CAT::FileType)->select(f|f.id=fileRef.repr())->asSequence()->first();
	//		var referencedFile:UML::Usage=file.addFileType(mpdComponent);
			var referencedFile:UML::Usage=file.addFileType(mpdComponent,purposeURI,natureURI);
			if(not(referencedFile.oclIsUndefined()))then{
			var elementImport:UML::ElementImport=new UML::ElementImport@pimUml();
			elementImport.importedElement:=referencedFile;
			elementImport.importingNamespace:=result;
		}endif;
	};
	var artifactStereotype:UML::Stereotype=NIEMModelPackageDescriptionFileSetStereotype;
	var stereotypeInstance:Stdlib::Element=result.applyStereotype(artifactStereotype);

//	stereotypeInstance.setFileSetTypeDescriptionText(self.descriptionText.value);
	stereotypeInstance.setDescriptionText(self.descriptionText.value);
	stereotypeInstance.setFileSetTypeExternalURI(self.externalURI.expandURI());
	// natureURI, purposeURI no longer exist
	//stereotypeInstance.setFileSetTypeNatureURI(self.natureURI.expandURI());
	//stereotypeInstance.setFileSetTypePurposeURI(self.purposeURI.expandURI());
}	
*/
query String::expandURI():String{
	if(self.oclIsUndefined())then {return self;} else{}endif;
	
	if(self.startsWith('[') and self.endsWith(']'))then{
		var prefix:String=self.substringAfter('[').substringBefore(':');
		var local:String=self.substringAfter(':').substringBefore(']');		
		var namespace:String=documentRoot.xMLNSPrefixMap->select(e|e.key=prefix).value->first();
		//log('expandURI '+self+', '+prefix+', '+local+', '+namespace);
		return namespace+local;
	}else{}endif;
	return self;
};
query String::mpdURItoBaseMpdUri(mpdVersionID:String):String{
	if(self.oclIsUndefined())then {return self;} else{}endif;
	if(mpdVersionID.oclIsUndefined())then {return self;} else{}endif;
	return self.replace('/'+mpdVersionID,'');
};
 	